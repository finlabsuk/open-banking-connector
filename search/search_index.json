{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-\\.]"},"docs":[{"location":"","text":"Overview Introduction Open Banking Connector is open-source software that manages and simplifies connections to UK Open Banking APIs. Its core is a collection of C# class libraries provided as packages in Nuget . It is designed for use with modern C# applications including \"plain\" apps (those without a .NET Generic Host ) and .NET Generic Host-based/ASP.NET Core apps. Its main purposes are: - to manage security aspects of Open Banking API accesses including registrations and tokens - to absorb bank differences including API version differences and behavioural/implementation differences so as much as possible the same API calls may be used for all banks It is currently focussed on support for domestic payments in UK Open Banking but has been designed for future extension to all UK Open Banking APIs. Uses Open Banking Connector can be used: as a connection layer allowing .NET backend software to connect to UK banks as a reference platform for creating and managing bank registrations used by other software. as a standalone bank test suite. Its built-in bank tests test Open Banking APIs in UK bank sandboxes and include a consent authoriser that automates web page user consent. To support the above, Open Banking Connector contains Bank Profiles for UK banks which provide reference configurations as used in the bank tests. Anyone is invited to contribute and update these profiles to extend the bank coverage of OBC and increase the value of this resource. Compatibility Open Banking Connector is a set of .NET Core libraries. They either target .NET Standard 2.1 or .NET Core 3.1, i.e. the current .NET Core LTS release. Going forward, we plan to evolve the master branch of Open Banking Connector (where active development takes place) to track the current LTS version of .NET approximately six months after release. Hence the next planned update is to .NET 6 approximately six months after its release. Open Banking Connector is designed to run in the cloud as part of two kinds of .NET app: - Apps based on .NET Generic Host (which may or may not be web apps but utilise features such as DI and Configuration) - Apps not based on .NET Generic Host (\"plain apps\") It requires both a relational database and key secret vault. We use EF Core for database access and test locally using SQLite. We use the local Secret Manager as a key vault for local testing. We have designed OBC to enable DB and key secret support on all main cloud platforms and are currently preparing to test on Azure using Azure Key Vault and Azure SQL. Interface Open Banking Connector provides an intuitive, Fluent REST-inspired interface. The idea is to have a single, standardised interface that works with multiple banks. More information may be found here . Open Banking API support Open Banking Connector supports multiple Open Banking APIs (depends on bank support) and provides a Fluent interface based on the latest supported version. More information may be found here . Documentation This documentation is available both in the GitHub repo and on the docs website . The documentation is divided into the following sections: Overview Getting Started How to Client Interface Architecture Contributor Info","title":"Overview"},{"location":"#overview","text":"","title":"Overview"},{"location":"#introduction","text":"Open Banking Connector is open-source software that manages and simplifies connections to UK Open Banking APIs. Its core is a collection of C# class libraries provided as packages in Nuget . It is designed for use with modern C# applications including \"plain\" apps (those without a .NET Generic Host ) and .NET Generic Host-based/ASP.NET Core apps. Its main purposes are: - to manage security aspects of Open Banking API accesses including registrations and tokens - to absorb bank differences including API version differences and behavioural/implementation differences so as much as possible the same API calls may be used for all banks It is currently focussed on support for domestic payments in UK Open Banking but has been designed for future extension to all UK Open Banking APIs.","title":"Introduction"},{"location":"#uses","text":"Open Banking Connector can be used: as a connection layer allowing .NET backend software to connect to UK banks as a reference platform for creating and managing bank registrations used by other software. as a standalone bank test suite. Its built-in bank tests test Open Banking APIs in UK bank sandboxes and include a consent authoriser that automates web page user consent. To support the above, Open Banking Connector contains Bank Profiles for UK banks which provide reference configurations as used in the bank tests. Anyone is invited to contribute and update these profiles to extend the bank coverage of OBC and increase the value of this resource.","title":"Uses"},{"location":"#compatibility","text":"Open Banking Connector is a set of .NET Core libraries. They either target .NET Standard 2.1 or .NET Core 3.1, i.e. the current .NET Core LTS release. Going forward, we plan to evolve the master branch of Open Banking Connector (where active development takes place) to track the current LTS version of .NET approximately six months after release. Hence the next planned update is to .NET 6 approximately six months after its release. Open Banking Connector is designed to run in the cloud as part of two kinds of .NET app: - Apps based on .NET Generic Host (which may or may not be web apps but utilise features such as DI and Configuration) - Apps not based on .NET Generic Host (\"plain apps\") It requires both a relational database and key secret vault. We use EF Core for database access and test locally using SQLite. We use the local Secret Manager as a key vault for local testing. We have designed OBC to enable DB and key secret support on all main cloud platforms and are currently preparing to test on Azure using Azure Key Vault and Azure SQL.","title":"Compatibility"},{"location":"#interface","text":"Open Banking Connector provides an intuitive, Fluent REST-inspired interface. The idea is to have a single, standardised interface that works with multiple banks. More information may be found here .","title":"Interface"},{"location":"#open-banking-api-support","text":"Open Banking Connector supports multiple Open Banking APIs (depends on bank support) and provides a Fluent interface based on the latest supported version. More information may be found here .","title":"Open Banking API support"},{"location":"#documentation","text":"This documentation is available both in the GitHub repo and on the docs website . The documentation is divided into the following sections: Overview Getting Started How to Client Interface Architecture Contributor Info","title":"Documentation"},{"location":"definitions/","text":"Definitions This page provides defintions for commonly used terms in Open Banking Connector. Software Statement Profile In UK Open Banking, a software statement is used to identify the entity (the \"TPP\") connecting to a bank. A software statement may be created in the UK Open Banking directory. A software statement and associated information are represented in Open Banking Connector as a Software Statement Profile . Each bank registration is based on a software statment profile and so it is necessary to set one up before attempting to create a bank registration. Software statement profiles are provided to Open Banking Connector as key secrets. OB Certificate Profile UK Open Banking uses certificates for signing and transport. In Open Banking Connector, information relating to a signing certificate and transport certificate pair is grouped together in an OB Certificate Profile . Software statement profiles are provided to Open Banking Connector as key secrets.","title":"Definitions"},{"location":"definitions/#definitions","text":"This page provides defintions for commonly used terms in Open Banking Connector.","title":"Definitions"},{"location":"definitions/#software-statement-profile","text":"In UK Open Banking, a software statement is used to identify the entity (the \"TPP\") connecting to a bank. A software statement may be created in the UK Open Banking directory. A software statement and associated information are represented in Open Banking Connector as a Software Statement Profile . Each bank registration is based on a software statment profile and so it is necessary to set one up before attempting to create a bank registration. Software statement profiles are provided to Open Banking Connector as key secrets.","title":"Software Statement Profile"},{"location":"definitions/#ob-certificate-profile","text":"UK Open Banking uses certificates for signing and transport. In Open Banking Connector, information relating to a signing certificate and transport certificate pair is grouped together in an OB Certificate Profile . Software statement profiles are provided to Open Banking Connector as key secrets.","title":"OB Certificate Profile"},{"location":"supported-open-banking-apis/","text":"Supported Open Banking APIs Open Banking Connector supports connections to banks using Open Banking APIs. This page details what APIs are supported. Generally the Open Banking Connector Fluent interface is based on the latest supported version of an API and older API versions are supported by request/response type mapping. For example, to send a DCR v3.1 request to a bank the request would first be mapped to a DCR v3.1 request and then the response mapped back to a v3.3 response. UK Open Banking Dynamic Client Registration API The UK Open Banking Dynamic Client Registration API is described here . Open Banking Connector supports the following versions of this API. API Version Type Mapping Comment v3.3 No type mapping is used Fluent interface based on this version v3.2 v3.3 request/repsonse types are mapped to v3.2 v3.1 v3.3 request/response types are mapped to v3.1 Open Banking Connector supports the following endpoints for this API. API Endpoint Fluent Interface Method POST /register requestBuilder.BankConfiguration.BankRegistrations.PostAsync() DELETE /register/{ClientId} requestBuilder.BankConfiguration.BankRegistrations.DeleteAsync() UK Open Banking Read-Write Payment Initation API The UK Open Banking Read-Write Payment Initiation API is described here . Open Banking Connector supports the following versions of this API. API Version Type Mapping Comment v3.1.6 No type mapping is used Fluent interface based on this version v3.1.4 v3.1.6 request/repsonse types are mapped to v3.1.4 [v3.1.2] Types present but mapping not yet implemented Open Banking Connector supports the following endpoints for this API. API Endpoint Fluent Interface Method POST \u200b/domestic-payment-consents requestBuilder .PaymentInitiation .DomesticPaymentConsents .PostAsync() GET \u200b/domestic-payment-consents/{ConsentId} requestBuilder .PaymentInitiation .DomesticPaymentConsents .GetAsync() GET \u200b/domestic-payment-consents/{ConsentId}/funds-confirmation requestBuilder .PaymentInitiation .DomesticPaymentConsents .GetFundsConfirmationAsync() POST \u200b/domestic-payments requestBuilder .PaymentInitiation .DomesticPayments .PostAsync() GET \u200b/domestic-payments\u200b/{DomesticPaymentId} requestBuilder .PaymentInitiation .DomesticPayments .GetAsync()","title":"Supported Open Banking API's"},{"location":"supported-open-banking-apis/#supported-open-banking-apis","text":"Open Banking Connector supports connections to banks using Open Banking APIs. This page details what APIs are supported. Generally the Open Banking Connector Fluent interface is based on the latest supported version of an API and older API versions are supported by request/response type mapping. For example, to send a DCR v3.1 request to a bank the request would first be mapped to a DCR v3.1 request and then the response mapped back to a v3.3 response.","title":"Supported Open Banking APIs"},{"location":"supported-open-banking-apis/#uk-open-banking-dynamic-client-registration-api","text":"The UK Open Banking Dynamic Client Registration API is described here . Open Banking Connector supports the following versions of this API. API Version Type Mapping Comment v3.3 No type mapping is used Fluent interface based on this version v3.2 v3.3 request/repsonse types are mapped to v3.2 v3.1 v3.3 request/response types are mapped to v3.1 Open Banking Connector supports the following endpoints for this API. API Endpoint Fluent Interface Method POST /register requestBuilder.BankConfiguration.BankRegistrations.PostAsync() DELETE /register/{ClientId} requestBuilder.BankConfiguration.BankRegistrations.DeleteAsync()","title":"UK Open Banking Dynamic Client Registration API"},{"location":"supported-open-banking-apis/#uk-open-banking-read-write-payment-initation-api","text":"The UK Open Banking Read-Write Payment Initiation API is described here . Open Banking Connector supports the following versions of this API. API Version Type Mapping Comment v3.1.6 No type mapping is used Fluent interface based on this version v3.1.4 v3.1.6 request/repsonse types are mapped to v3.1.4 [v3.1.2] Types present but mapping not yet implemented Open Banking Connector supports the following endpoints for this API. API Endpoint Fluent Interface Method POST \u200b/domestic-payment-consents requestBuilder .PaymentInitiation .DomesticPaymentConsents .PostAsync() GET \u200b/domestic-payment-consents/{ConsentId} requestBuilder .PaymentInitiation .DomesticPaymentConsents .GetAsync() GET \u200b/domestic-payment-consents/{ConsentId}/funds-confirmation requestBuilder .PaymentInitiation .DomesticPaymentConsents .GetFundsConfirmationAsync() POST \u200b/domestic-payments requestBuilder .PaymentInitiation .DomesticPayments .PostAsync() GET \u200b/domestic-payments\u200b/{DomesticPaymentId} requestBuilder .PaymentInitiation .DomesticPayments .GetAsync()","title":"UK Open Banking Read-Write Payment Initation API"},{"location":"architecture/","text":"OpenBanking.Library.Connector architecture Suggested API Components Classes Diagrams Diagrams have been created with draw.io free accounts and embedded as PNGs. The source files are *.drawio files.","title":"Architecture"},{"location":"architecture/#openbankinglibraryconnector-architecture","text":"Suggested API Components Classes","title":"OpenBanking.Library.Connector architecture"},{"location":"architecture/#diagrams","text":"Diagrams have been created with draw.io free accounts and embedded as PNGs. The source files are *.drawio files.","title":"Diagrams"},{"location":"architecture/Components/","text":"Components OpenBanking.Library.Connector OpenBanking.Library.Connector.IntegrationTests OpenBanking.Library.Connector.Benchmarks OpenBanking.Library.Service.Payments","title":"Components"},{"location":"architecture/Components/#components","text":"OpenBanking.Library.Connector OpenBanking.Library.Connector.IntegrationTests OpenBanking.Library.Connector.Benchmarks OpenBanking.Library.Service.Payments","title":"Components"},{"location":"architecture/OBC_Connector_Classes/","text":"Classes Interfaces IConfigurationProvider An interface for implementing runtime configuration. IClientProfileProvider An interface for implementing IInstrumentationClient An interface for implementing instrumentation concerns - tracing, logging, etc. Different platforms will have quite different requirements. IKeySecretProvider An interface for implementing a key secret provider. Implementations will implement platform concerns, e.g. Azure Key Vault. Fluent Interfaces/DSL TBD Models Public Model Canonical data entities for clients Model Transformations OB V1.x Auto-generated OpenBanking entities Networking ApiClient Base class for HTTP requests","title":"Classes"},{"location":"architecture/OBC_Connector_Classes/#classes","text":"","title":"Classes"},{"location":"architecture/OBC_Connector_Classes/#interfaces","text":"","title":"Interfaces"},{"location":"architecture/OBC_Connector_Classes/#iconfigurationprovider","text":"An interface for implementing runtime configuration.","title":"IConfigurationProvider"},{"location":"architecture/OBC_Connector_Classes/#iclientprofileprovider","text":"An interface for implementing","title":"IClientProfileProvider"},{"location":"architecture/OBC_Connector_Classes/#iinstrumentationclient","text":"An interface for implementing instrumentation concerns - tracing, logging, etc. Different platforms will have quite different requirements.","title":"IInstrumentationClient"},{"location":"architecture/OBC_Connector_Classes/#ikeysecretprovider","text":"An interface for implementing a key secret provider. Implementations will implement platform concerns, e.g. Azure Key Vault.","title":"IKeySecretProvider"},{"location":"architecture/OBC_Connector_Classes/#fluent-interfacesdsl","text":"TBD","title":"Fluent Interfaces/DSL"},{"location":"architecture/OBC_Connector_Classes/#models","text":"","title":"Models"},{"location":"architecture/OBC_Connector_Classes/#public-model","text":"Canonical data entities for clients","title":"Public Model"},{"location":"architecture/OBC_Connector_Classes/#model-transformations","text":"","title":"Model Transformations"},{"location":"architecture/OBC_Connector_Classes/#ob-v1x","text":"Auto-generated OpenBanking entities","title":"OB V1.x"},{"location":"architecture/OBC_Connector_Classes/#networking","text":"","title":"Networking"},{"location":"architecture/OBC_Connector_Classes/#apiclient","text":"Base class for HTTP requests","title":"ApiClient"},{"location":"architecture/OpenBanking.Connector.Benchmarks/","text":"OpenBanking.Library.Connector.Benchmarks Benchmarks is a standalone project intended to garner software performance benchmarks. It\u2019s intended to benchmark OpenBanking.Library.Connector code, and not the PISPs it integrates with. Its reports will help guide optimisation efforts and provide proof-of-quality to potential users. Implementation .Net Core 2.2 / C# 7 console application Incorporates BenchmarkDotNet (https://benchmarkdotnet.org/) Runtime profile Executed upon each build profiling with in-process mocks Executed upon integration test runs, for profiling against sandbox & live APIs Reports For selected in-process code pathways: Mean/StdDev/Min/Max/Median execution times Memory & garbage collection pressure .Net Core 2.2 & (.Net Core 3 in future) For selected sandbox APIs: Mean/StdDev/Min/Max/Median/Quartile execution times Memory & garbage collection pressure .Net Core 2.2 (.Net Core 3 in future)","title":"Benchmarks"},{"location":"architecture/OpenBanking.Connector.Benchmarks/#openbankinglibraryconnectorbenchmarks","text":"Benchmarks is a standalone project intended to garner software performance benchmarks. It\u2019s intended to benchmark OpenBanking.Library.Connector code, and not the PISPs it integrates with. Its reports will help guide optimisation efforts and provide proof-of-quality to potential users.","title":"OpenBanking.Library.Connector.Benchmarks"},{"location":"architecture/OpenBanking.Connector.Benchmarks/#implementation","text":".Net Core 2.2 / C# 7 console application Incorporates BenchmarkDotNet (https://benchmarkdotnet.org/)","title":"Implementation"},{"location":"architecture/OpenBanking.Connector.Benchmarks/#runtime-profile","text":"Executed upon each build profiling with in-process mocks Executed upon integration test runs, for profiling against sandbox & live APIs","title":"Runtime profile"},{"location":"architecture/OpenBanking.Connector.Benchmarks/#reports","text":"For selected in-process code pathways: Mean/StdDev/Min/Max/Median execution times Memory & garbage collection pressure .Net Core 2.2 & (.Net Core 3 in future) For selected sandbox APIs: Mean/StdDev/Min/Max/Median/Quartile execution times Memory & garbage collection pressure .Net Core 2.2 (.Net Core 3 in future)","title":"Reports"},{"location":"architecture/OpenBanking.Connector.IntegrationTests/","text":"OpenBanking.Library.Connector.IntegrationTests OpenBanking.Library.Connector.IntegrationTests is a single assembly containing all integration tests. These tests will cover: integration testing against our internal sandbox mock APIs integration testing against PISP partners' sandbox APIs QoS checks against PISP partner sandbox APIs & optionally live PISP APIs Dependencies: PISP sandbox mocks running getsandbox mocks PISP Partner sandboxes PISP partner sandboxes Runtime: Continual testing against our internal sandbox mock APIs - isolated tests On-demand execution against PISP Partner sandbox & live APIs Implementation: .NET Core 2 / C# 7 XUnit/BDD tests The tests' first facade is against the package\u2019s C# code and not HTTP endpoints. Specflow is rules out: it has licence requirements, and we want to make our source as widely usable as possible. Configuration: SSAs Certs Target API URLs Retained within the test project itself Namespaces Name Purpose LocalMockTests Tests against internal mocks PispTests Tests against PISP Sandboxes PispHealthTests Tests against PISP Sandbox & API to gauge health and discover API changes","title":"Integration Tests"},{"location":"architecture/OpenBanking.Connector.IntegrationTests/#openbankinglibraryconnectorintegrationtests","text":"OpenBanking.Library.Connector.IntegrationTests is a single assembly containing all integration tests. These tests will cover: integration testing against our internal sandbox mock APIs integration testing against PISP partners' sandbox APIs QoS checks against PISP partner sandbox APIs & optionally live PISP APIs","title":"OpenBanking.Library.Connector.IntegrationTests"},{"location":"architecture/OpenBanking.Connector.IntegrationTests/#dependencies","text":"PISP sandbox mocks running getsandbox mocks PISP Partner sandboxes PISP partner sandboxes","title":"Dependencies:"},{"location":"architecture/OpenBanking.Connector.IntegrationTests/#runtime","text":"Continual testing against our internal sandbox mock APIs - isolated tests On-demand execution against PISP Partner sandbox & live APIs","title":"Runtime:"},{"location":"architecture/OpenBanking.Connector.IntegrationTests/#implementation","text":".NET Core 2 / C# 7 XUnit/BDD tests The tests' first facade is against the package\u2019s C# code and not HTTP endpoints. Specflow is rules out: it has licence requirements, and we want to make our source as widely usable as possible.","title":"Implementation:"},{"location":"architecture/OpenBanking.Connector.IntegrationTests/#configuration","text":"SSAs Certs Target API URLs Retained within the test project itself","title":"Configuration:"},{"location":"architecture/OpenBanking.Connector.IntegrationTests/#namespaces","text":"Name Purpose LocalMockTests Tests against internal mocks PispTests Tests against PISP Sandboxes PispHealthTests Tests against PISP Sandbox & API to gauge health and discover API changes","title":"Namespaces"},{"location":"architecture/OpenBanking.Connector/","text":"OpenBanking.Library.Connector.Payments OpenBanking.Library.Connector.Payments is the main deliverable assembly for OBC.NET. Features: .Net Standard library for direct integration into .Net Core/Xamarin applications and services Heterogenous Bank PISP APIs are abstracted to a canonical model Fluent, domain-driven client interface Interface abstractions for external services (DB, key store, instrumentation, etc) Dependency injection following ASP.NET Core DI patterns Implementation: .NET Standard 2 C# 7 We intend to upgrade to C# 8 in the near future. Namespaces: The main package's root namespace is FinnovationLabs.OpenBanking.Library.Connector . Namespace Purpose .Configuration Run-time configuration .Http HTTP utilities .Instrumentation Instrumentation abstractions .Json JSON utilities .Model Entity declarations. These describe the structure of messages, not their behaviour. .Model.Public All client-facing entity types. These are canonical models that will cover versions .Model.Payments Internal, auto-generated entity code. These are all sourced from OpenBanking PISP model OpenAPIs .Model.Payments.V3_1_0 OpenBanking OpenAPI v3.1.0 .Model.Payments.V3_1_1 OpenBanking OpenAPI v3.1.1 .Model.Payments.V3_1_2 OpenBanking OpenAPI v3.1.2 .Payments Payments behaviour implementation .Security JWT/JWS utilities Usage See here","title":"OpenBanking.Library.Connector.Payments"},{"location":"architecture/OpenBanking.Connector/#openbankinglibraryconnectorpayments","text":"OpenBanking.Library.Connector.Payments is the main deliverable assembly for OBC.NET.","title":"OpenBanking.Library.Connector.Payments"},{"location":"architecture/OpenBanking.Connector/#features","text":".Net Standard library for direct integration into .Net Core/Xamarin applications and services Heterogenous Bank PISP APIs are abstracted to a canonical model Fluent, domain-driven client interface Interface abstractions for external services (DB, key store, instrumentation, etc) Dependency injection following ASP.NET Core DI patterns","title":"Features:"},{"location":"architecture/OpenBanking.Connector/#implementation","text":".NET Standard 2 C# 7 We intend to upgrade to C# 8 in the near future.","title":"Implementation:"},{"location":"architecture/OpenBanking.Connector/#namespaces","text":"The main package's root namespace is FinnovationLabs.OpenBanking.Library.Connector . Namespace Purpose .Configuration Run-time configuration .Http HTTP utilities .Instrumentation Instrumentation abstractions .Json JSON utilities .Model Entity declarations. These describe the structure of messages, not their behaviour. .Model.Public All client-facing entity types. These are canonical models that will cover versions .Model.Payments Internal, auto-generated entity code. These are all sourced from OpenBanking PISP model OpenAPIs .Model.Payments.V3_1_0 OpenBanking OpenAPI v3.1.0 .Model.Payments.V3_1_1 OpenBanking OpenAPI v3.1.1 .Model.Payments.V3_1_2 OpenBanking OpenAPI v3.1.2 .Payments Payments behaviour implementation .Security JWT/JWS utilities","title":"Namespaces:"},{"location":"architecture/OpenBanking.Connector/#usage","text":"See here","title":"Usage"},{"location":"architecture/OpenBanking.Service.Payments/","text":"OpenBanking.Service.Payments A sample Azure Function project demonstrating OpenBankingConnector.Net. It is intended to guide users in the library's use on a local development machine. As such it is a simplified form and not intended to be production ready. Runtime Azure Function v2 .Net core 2 (Core 3 once full support is applied) C# 7 Endpoints See here Dependencies Type Dependency Notes Database Cosmos DB CosmosDB is the defacto elastic high availability database in Azure. Instrumentation Azure Application Insights App Insights is the standard application instrumentation platform within Azure. Keystore Azure Key Vault Standard key storage platform within Azure.","title":"Service Payments"},{"location":"architecture/OpenBanking.Service.Payments/#openbankingservicepayments","text":"A sample Azure Function project demonstrating OpenBankingConnector.Net. It is intended to guide users in the library's use on a local development machine. As such it is a simplified form and not intended to be production ready.","title":"OpenBanking.Service.Payments"},{"location":"architecture/OpenBanking.Service.Payments/#runtime","text":"Azure Function v2 .Net core 2 (Core 3 once full support is applied) C# 7","title":"Runtime"},{"location":"architecture/OpenBanking.Service.Payments/#endpoints","text":"See here","title":"Endpoints"},{"location":"architecture/OpenBanking.Service.Payments/#dependencies","text":"Type Dependency Notes Database Cosmos DB CosmosDB is the defacto elastic high availability database in Azure. Instrumentation Azure Application Insights App Insights is the standard application instrumentation platform within Azure. Keystore Azure Key Vault Standard key storage platform within Azure.","title":"Dependencies"},{"location":"architecture/Suggested_API_endpoints/","text":"API Endpoints These are the suggested HTTP API endpoints for sample services. These will help drive implementations for sample & test services by showing the extent of future client-API interactions. Please note that our intention is to provide a library and not to provide a production-quality service: the service will use the library. Area Name Method Path Request Response General Create Software Statement Profiles POST /software-statement-profiles SoftwareStatementProfile SoftwareStatementProfile Create OB Client PRofile POST /register OBClientProfile OBClientProfile PISP API Create Domestic Payment Consents POST /pisp/domestic-payment-constents OBWriteDomesticConentPublic OBWriteDomesticConsentResponsePublic Get Domestic Payment Consents GET /pisp/domestic-payment-consents/{consentId} OBWriteDomesticConsentResponsePublic Get Domestic Payment Consents (FC) GET /pisp/domestic-payment-consents/{consentId}/funds-confirmation OBWriteFundsConfirmationResponsePublic Create Domestic Payments POST /pisp/domestic-payments OBWriteDomesticPublic OBWriteDomesticResponsePublic Get Domestic Payments GET /pisp/domestic-payments/{domesticPaymentId} OBWriteDomesticConstentResponsePublic \"Public\" types will eventually be denoted by their namespace. An API would not expose a type with that suffix. FC: Funds Confirmation","title":"Suggested API endpoints"},{"location":"architecture/Suggested_API_endpoints/#api-endpoints","text":"These are the suggested HTTP API endpoints for sample services. These will help drive implementations for sample & test services by showing the extent of future client-API interactions. Please note that our intention is to provide a library and not to provide a production-quality service: the service will use the library. Area Name Method Path Request Response General Create Software Statement Profiles POST /software-statement-profiles SoftwareStatementProfile SoftwareStatementProfile Create OB Client PRofile POST /register OBClientProfile OBClientProfile PISP API Create Domestic Payment Consents POST /pisp/domestic-payment-constents OBWriteDomesticConentPublic OBWriteDomesticConsentResponsePublic Get Domestic Payment Consents GET /pisp/domestic-payment-consents/{consentId} OBWriteDomesticConsentResponsePublic Get Domestic Payment Consents (FC) GET /pisp/domestic-payment-consents/{consentId}/funds-confirmation OBWriteFundsConfirmationResponsePublic Create Domestic Payments POST /pisp/domestic-payments OBWriteDomesticPublic OBWriteDomesticResponsePublic Get Domestic Payments GET /pisp/domestic-payments/{domesticPaymentId} OBWriteDomesticConstentResponsePublic \"Public\" types will eventually be denoted by their namespace. An API would not expose a type with that suffix. FC: Funds Confirmation","title":"API Endpoints"},{"location":"contributor-info/","text":"Contributor info Open Banking Connector is an open-source project and welcomes feedback and any improvements. This sections provides guidelines regarding: documentation","title":"Contributor info"},{"location":"contributor-info/#contributor-info","text":"Open Banking Connector is an open-source project and welcomes feedback and any improvements. This sections provides guidelines regarding: documentation","title":"Contributor info"},{"location":"contributor-info/documentation/","text":"Documentation The project documentation is written in Markdown and configured using a mkdocs.yml file. The documentation can be viewed on: /docs folder in the Github repo docs website generated using mkdocs This section is split into two sections: How to update documentation How to deploy new documentation","title":"Documentation"},{"location":"contributor-info/documentation/#documentation","text":"The project documentation is written in Markdown and configured using a mkdocs.yml file. The documentation can be viewed on: /docs folder in the Github repo docs website generated using mkdocs This section is split into two sections: How to update documentation How to deploy new documentation","title":"Documentation"},{"location":"contributor-info/documentation/deploy-documentation/","text":"Deploy documentation Here are the steps required to: prepare for deployment deploy documentation to website Prepare for deployment Generate Docs website (Mkdocs) To generate the docs website based on the contents of a local open-banking-connector repo (i.e. latest edits), you will need to install Python 3 and Material for MkDocs (mkdocs-material). Assuming you have installed Python, you can install Material for MkDocs as follows: pip install mkdocs-material # if mkdocs-material not installed Preview website To deploy the website locally for inspection and testing, please cd to the OBC repo root and run the following command: mkdocs serve This will return the URL you can use to see the website. Tags Everytime website is regenerated, point links to a new tag: decide on a version number create tag based on version number git tag \"docs_v1.0\" push tag to github git push publicRemote docs_v1.0 Github tags are used to create a version number for a new release. This separates different versions of code and links depending on the version. Overview page on website For the overview page on the website, an overview folder with a README.md was created for the website heading feature. This is not compatible with Github so this folder was added to .gitignore to stop it from being committed. There is a separate project /docs/README.md file which is visible on github. Link Path change from relative to absolute Whilst making local changes it is recommended to use relative links: (../../../../src/..../BankConfigurationMethods.cs#39) However, before deploying links must be changed to absolute links: (https://github.com/finlabsuk/open-banking-connector/blob/docs_v1.0/src/..../BankConfigurationMethods.cs#39). Do a search and replace to speed this conversion up. (visual studio code) Search: \\(./.*?/src Replace: https://github.com/finlabsuk/open-banking-connector/blob/docs_v1.0/src Deploy to website If you have permissions, you can update the public website on GitHub Pages using: mkdocs gh-deploy -m \"Test deployment\" -r publicRemote # adjust commit message and remote as required","title":"Deploy"},{"location":"contributor-info/documentation/deploy-documentation/#deploy-documentation","text":"Here are the steps required to: prepare for deployment deploy documentation to website","title":"Deploy documentation"},{"location":"contributor-info/documentation/deploy-documentation/#prepare-for-deployment","text":"","title":"Prepare for deployment"},{"location":"contributor-info/documentation/deploy-documentation/#generate-docs-website-mkdocs","text":"To generate the docs website based on the contents of a local open-banking-connector repo (i.e. latest edits), you will need to install Python 3 and Material for MkDocs (mkdocs-material). Assuming you have installed Python, you can install Material for MkDocs as follows: pip install mkdocs-material # if mkdocs-material not installed","title":"Generate Docs website (Mkdocs)"},{"location":"contributor-info/documentation/deploy-documentation/#preview-website","text":"To deploy the website locally for inspection and testing, please cd to the OBC repo root and run the following command: mkdocs serve This will return the URL you can use to see the website.","title":"Preview website"},{"location":"contributor-info/documentation/deploy-documentation/#tags","text":"Everytime website is regenerated, point links to a new tag: decide on a version number create tag based on version number git tag \"docs_v1.0\" push tag to github git push publicRemote docs_v1.0 Github tags are used to create a version number for a new release. This separates different versions of code and links depending on the version.","title":"Tags"},{"location":"contributor-info/documentation/deploy-documentation/#overview-page-on-website","text":"For the overview page on the website, an overview folder with a README.md was created for the website heading feature. This is not compatible with Github so this folder was added to .gitignore to stop it from being committed. There is a separate project /docs/README.md file which is visible on github.","title":"Overview page on website"},{"location":"contributor-info/documentation/deploy-documentation/#link-path-change-from-relative-to-absolute","text":"Whilst making local changes it is recommended to use relative links: (../../../../src/..../BankConfigurationMethods.cs#39) However, before deploying links must be changed to absolute links: (https://github.com/finlabsuk/open-banking-connector/blob/docs_v1.0/src/..../BankConfigurationMethods.cs#39). Do a search and replace to speed this conversion up. (visual studio code) Search: \\(./.*?/src Replace: https://github.com/finlabsuk/open-banking-connector/blob/docs_v1.0/src","title":"Link Path change from relative to absolute"},{"location":"contributor-info/documentation/deploy-documentation/#deploy-to-website","text":"If you have permissions, you can update the public website on GitHub Pages using: mkdocs gh-deploy -m \"Test deployment\" -r publicRemote # adjust commit message and remote as required","title":"Deploy to website"},{"location":"contributor-info/documentation/update-documentation/","text":"Update documentation Here are the steps required to: update current documentation using markdown add new documentation Update documentation To update the current documentation: go to /docs repo folder edit folder name in /docs edit the README.md file inside the folder edit the file.md file Any changes made must be applied to the nav section in the mkdocs.yml . (e.g. file/folder rename or file structure changes) Links to content in the repo must be relative links. For example: [update documentation](./update-documentation.md) The next step is to generate docs website and deploy documentation. Add new documentation To add new documentation: go to /docs repo folder create new folder in /docs create new README.md file inside the folder create file.md file In mkdocs.yml , the nav section must include your changes: nav: - SectionTitle: - folder/file.md - PageTitle: file.md The next step is to generate docs website and deploy documentation.","title":"Update"},{"location":"contributor-info/documentation/update-documentation/#update-documentation","text":"Here are the steps required to: update current documentation using markdown add new documentation","title":"Update documentation"},{"location":"contributor-info/documentation/update-documentation/#update-documentation_1","text":"To update the current documentation: go to /docs repo folder edit folder name in /docs edit the README.md file inside the folder edit the file.md file Any changes made must be applied to the nav section in the mkdocs.yml . (e.g. file/folder rename or file structure changes) Links to content in the repo must be relative links. For example: [update documentation](./update-documentation.md) The next step is to generate docs website and deploy documentation.","title":"Update documentation"},{"location":"contributor-info/documentation/update-documentation/#add-new-documentation","text":"To add new documentation: go to /docs repo folder create new folder in /docs create new README.md file inside the folder create file.md file In mkdocs.yml , the nav section must include your changes: nav: - SectionTitle: - folder/file.md - PageTitle: file.md The next step is to generate docs website and deploy documentation.","title":"Add new documentation"},{"location":"get-started/","text":"Get Started Open Banking Connector is a collection of C# class libraries provided as packages in Nuget. Overview In order to use Open Banking Connector in your C# Open Banking application you will need to: Select a package from Nuget and include it in your application The following additional setup steps are also required and might differ between development, staging and production environments: Install the UK Open Banking root certificate Configure settings for Open Banking Connector including a database connection string Configure secrets for Open Banking Connector including software statements and Open Banking certificates You can then use Open Banking Connector's interface within your application. Please see interface docs for examples of simple tasks such as configuring a bank (including registration creation) and creating a payment consent etc. Select a Nuget package The following Open Banking Connector packages are available and you should select one based on the type of app that will include it. App Type Nuget Package \"Plain\" app (no .NET Generic Host) FinnovationLabs.OpenBanking.Library.Connector .NET Generic Host app FinnovationLabs.OpenBanking.Library.Connector.GenericHost .NET Generic Host app (Azure-hosted) ASP.NET Core app FinnovationLabs.OpenBanking.Library.Connector.Web You will also need to consider how you will handle bank authentication redirects. You can handle these externally to Open Banking Connector and provide authentication results via its Fluent interface. Or, if you use FinnovationLabs.OpenBanking.Library.Connector.Web in an ASP.NET Core app, Open Banking Connector provides web endpoints to absorb authentication redirects. Install the UK Open Banking root certificate For a development environment, please follow instructions here . For staging/production environment, please follow your internal procedures. Configure settings Open Banking Connector is configured by settings which e.g. provide a database connection string and limits which SoftwareStatementProfiles are loaded. More information is provided here. Configure secrets Open Banking Connector is also configured by secrets which provide sensitive information such as SoftwareStatementProfiles and ObCertificateProfiles. More information is provided here.","title":"Get Started"},{"location":"get-started/#get-started","text":"Open Banking Connector is a collection of C# class libraries provided as packages in Nuget.","title":"Get Started"},{"location":"get-started/#overview","text":"In order to use Open Banking Connector in your C# Open Banking application you will need to: Select a package from Nuget and include it in your application The following additional setup steps are also required and might differ between development, staging and production environments: Install the UK Open Banking root certificate Configure settings for Open Banking Connector including a database connection string Configure secrets for Open Banking Connector including software statements and Open Banking certificates You can then use Open Banking Connector's interface within your application. Please see interface docs for examples of simple tasks such as configuring a bank (including registration creation) and creating a payment consent etc.","title":"Overview"},{"location":"get-started/#select-a-nuget-package","text":"The following Open Banking Connector packages are available and you should select one based on the type of app that will include it. App Type Nuget Package \"Plain\" app (no .NET Generic Host) FinnovationLabs.OpenBanking.Library.Connector .NET Generic Host app FinnovationLabs.OpenBanking.Library.Connector.GenericHost .NET Generic Host app (Azure-hosted) ASP.NET Core app FinnovationLabs.OpenBanking.Library.Connector.Web You will also need to consider how you will handle bank authentication redirects. You can handle these externally to Open Banking Connector and provide authentication results via its Fluent interface. Or, if you use FinnovationLabs.OpenBanking.Library.Connector.Web in an ASP.NET Core app, Open Banking Connector provides web endpoints to absorb authentication redirects.","title":"Select a Nuget package"},{"location":"get-started/#install-the-uk-open-banking-root-certificate","text":"For a development environment, please follow instructions here . For staging/production environment, please follow your internal procedures.","title":"Install the UK Open Banking root certificate"},{"location":"get-started/#configure-settings","text":"Open Banking Connector is configured by settings which e.g. provide a database connection string and limits which SoftwareStatementProfiles are loaded. More information is provided here.","title":"Configure settings"},{"location":"get-started/#configure-secrets","text":"Open Banking Connector is also configured by secrets which provide sensitive information such as SoftwareStatementProfiles and ObCertificateProfiles. More information is provided here.","title":"Configure secrets"},{"location":"get-started/configure-secrets/","text":"Setting up a software statement profile in secrets storage OBC uses key secrets to store sensitive data such as software statment profiles. A software statement profile consists of a software statement (created in the UK Open Banking directory) and associated information (keys, certificates, etc). Each software statement identifies a third-party entity that can create registrations (clients) with banks. To use OBC, at least one software statement profile must be provided in secrets storage. This will allow the creation of bank registrations and is a pre-requisite for using OBC. During development, it is suggested to use the ASP.NET Core Secret Manager as the OBC secrets store. This is a local secrets.json file stored outside of the project and well away from your Git repo (!). This page explains how to add a software statement profile to the ASP.NET Core Secret Manager. Software statement profile secrets The structure of a software statement profile is given and documented by the C# class FinnovationLabs.OpenBanking.Library.Connector.Configuration.SoftwareStatementProfile . Each property of this class is a string and corresponds to a single secret. To specify a software statement profile via secrets, you will need to decide upon an ID for the profile and then create secrets using the key format SoftwareStatementProfiles:<Profile ID>:<C# Property Name> . For example, here is JSON specifying secrets for a software statement profile with ID All : { \"SoftwareStatementProfiles:All:CertificateType\" : \"LegacyOB\" , \"SoftwareStatementProfiles:All:SigningKeyId\" : \"mySigningKeyId\" , \"SoftwareStatementProfiles:All:SigningKey\" : \"-----BEGIN PRIVATE KEY-----\\nmyKeyLine1\\nmyKeyLine2\\n-----END PRIVATE KEY-----\\n\" , \"SoftwareStatementProfiles:All:SigningCertificate\" : \"-----BEGIN CERTIFICATE-----\\nmyCertLine1\\nmyCertLine2\\n-----END CERTIFICATE-----\\n\" , \"SoftwareStatementProfiles:All:TransportKey\" : \"-----BEGIN PRIVATE KEY-----\\nmyKeyLine1\\nmyKeyLine2\\n-----END PRIVATE KEY-----\\n\" , \"SoftwareStatementProfiles:All:TransportCertificate\" : \"-----BEGIN CERTIFICATE-----\\nmyCertLine1\\nmyCertLine2\\n-----END CERTIFICATE-----\\n\" , \"SoftwareStatementProfiles:All:SoftwareStatement\" : \"mySoftwareStatementPart1.mySoftwareStatementPart2.mySoftwareStatementPart3\" , \"SoftwareStatementProfiles:All:DefaultFragmentRedirectUrl\" : \"https://example.com/auth/fragment-redirect\" } Adding a software statement profile to the ASP.NET Core Secret Manager To add a software statement profile to the ASP.NET Core Secret Manager, first create a secrets.json file with JSON specifying your software statement profile secrets (see previous section). Then place this file in a new secrets folder named the same as the UserSecretsId . The default UserSecretsId for OBC is currently specified in applicable .csproj files as: <UserSecretsId> aa921213-9461-4f9e-8fec-153624ec67ad </UserSecretsId> This secrets folder should be created in the Microsoft UserSecrets folder appropriate for your platform. (Note: Please also remember to supply the IDs of active software statement profiles to OBC via configuration.)","title":"Configure Secrets"},{"location":"get-started/configure-secrets/#setting-up-a-software-statement-profile-in-secrets-storage","text":"OBC uses key secrets to store sensitive data such as software statment profiles. A software statement profile consists of a software statement (created in the UK Open Banking directory) and associated information (keys, certificates, etc). Each software statement identifies a third-party entity that can create registrations (clients) with banks. To use OBC, at least one software statement profile must be provided in secrets storage. This will allow the creation of bank registrations and is a pre-requisite for using OBC. During development, it is suggested to use the ASP.NET Core Secret Manager as the OBC secrets store. This is a local secrets.json file stored outside of the project and well away from your Git repo (!). This page explains how to add a software statement profile to the ASP.NET Core Secret Manager.","title":"Setting up a software statement profile in secrets storage"},{"location":"get-started/configure-secrets/#software-statement-profile-secrets","text":"The structure of a software statement profile is given and documented by the C# class FinnovationLabs.OpenBanking.Library.Connector.Configuration.SoftwareStatementProfile . Each property of this class is a string and corresponds to a single secret. To specify a software statement profile via secrets, you will need to decide upon an ID for the profile and then create secrets using the key format SoftwareStatementProfiles:<Profile ID>:<C# Property Name> . For example, here is JSON specifying secrets for a software statement profile with ID All : { \"SoftwareStatementProfiles:All:CertificateType\" : \"LegacyOB\" , \"SoftwareStatementProfiles:All:SigningKeyId\" : \"mySigningKeyId\" , \"SoftwareStatementProfiles:All:SigningKey\" : \"-----BEGIN PRIVATE KEY-----\\nmyKeyLine1\\nmyKeyLine2\\n-----END PRIVATE KEY-----\\n\" , \"SoftwareStatementProfiles:All:SigningCertificate\" : \"-----BEGIN CERTIFICATE-----\\nmyCertLine1\\nmyCertLine2\\n-----END CERTIFICATE-----\\n\" , \"SoftwareStatementProfiles:All:TransportKey\" : \"-----BEGIN PRIVATE KEY-----\\nmyKeyLine1\\nmyKeyLine2\\n-----END PRIVATE KEY-----\\n\" , \"SoftwareStatementProfiles:All:TransportCertificate\" : \"-----BEGIN CERTIFICATE-----\\nmyCertLine1\\nmyCertLine2\\n-----END CERTIFICATE-----\\n\" , \"SoftwareStatementProfiles:All:SoftwareStatement\" : \"mySoftwareStatementPart1.mySoftwareStatementPart2.mySoftwareStatementPart3\" , \"SoftwareStatementProfiles:All:DefaultFragmentRedirectUrl\" : \"https://example.com/auth/fragment-redirect\" }","title":"Software statement profile secrets"},{"location":"get-started/configure-secrets/#adding-a-software-statement-profile-to-the-aspnet-core-secret-manager","text":"To add a software statement profile to the ASP.NET Core Secret Manager, first create a secrets.json file with JSON specifying your software statement profile secrets (see previous section). Then place this file in a new secrets folder named the same as the UserSecretsId . The default UserSecretsId for OBC is currently specified in applicable .csproj files as: <UserSecretsId> aa921213-9461-4f9e-8fec-153624ec67ad </UserSecretsId> This secrets folder should be created in the Microsoft UserSecrets folder appropriate for your platform. (Note: Please also remember to supply the IDs of active software statement profiles to OBC via configuration.)","title":"Adding a software statement profile to the ASP.NET Core Secret Manager"},{"location":"get-started/configure-settings/","text":"Configure Open Banking Connector settings Settings are used to configure Open Bankinng Connector alongside secrets which provide sensitive configuration data. They are organised into groups defined by C# classes. They can be provided in various forms depending on the type of app using Open Banking Connector. Two groups of settings are currently defined: Group C# class Description Open Banking Connector OpenBankingConnectorSettings settings related to Core Open Banking functionality including the database connection string Bank Profile Settings BankProfilesSettings settings related to Bank Profiles which is an optional feature of Open Bnaking Connector providing configuration for UK bank sandboxes Available Settings Group (C# class): Open Banking Connector Setting Example value Description \"SqliteDb ConnectionString\": \"Data Source=../../../../OpenBanking.Library. Connector/sqliteTestDb.db\" This string specifies the type of connection string being used. The path to the .db file will be specified. \"EnsureDbCreated\": \"true\" This settings identifies whether the database has been created. Group (C# class): Bank Profile Settings Setting Example value Description \"DataDirectory\":{ \"Windows\": Specified different OS types. \"Windows\": \"C:/Repos/open-banking-connector-csharp-data/bankProfileData\" Displays the specific path to the data directory for each OS. Configure settings for a \"Plain\" app (app without .NET Generic Host) user has freedom to create settings in any way and use them when creating the Open Banking Connector request object. TODO: Need to set up setting providers for each settings group. (Bank Profile and Open Banking Connector) Configure settings for .NET Generic Host or ASP.NET Core app Microsoft ASP.NET Core is configured using various sources. One configuration method is the use of settings files such as appsettings.json. Please see Microsoft link for more information. The two setting groups can be used to create setting sections in appsettings.json or the settings can be set individually through the use of environment variables. For example: You could add the following to appsettings.json to configure the BankProfileSettings settings group. \"BankProfiles\" : { \"DataDirectory\" : { \"Windows\" : \"C:/Repos/open-banking-connector-csharp-data/bankProfileData\" , \"MacOs\" : \"~/Repos/open-banking-connector-csharp-data/bankProfileData\" , \"Linux\" : \"~/Repos/open-banking-connector-csharp-data/bankProfileData\" } } Refer to Microsoft link for more examples of how the C# code maps to the AppSettings file.","title":"Configure Settings"},{"location":"get-started/configure-settings/#configure-open-banking-connector-settings","text":"Settings are used to configure Open Bankinng Connector alongside secrets which provide sensitive configuration data. They are organised into groups defined by C# classes. They can be provided in various forms depending on the type of app using Open Banking Connector. Two groups of settings are currently defined: Group C# class Description Open Banking Connector OpenBankingConnectorSettings settings related to Core Open Banking functionality including the database connection string Bank Profile Settings BankProfilesSettings settings related to Bank Profiles which is an optional feature of Open Bnaking Connector providing configuration for UK bank sandboxes","title":"Configure Open Banking Connector settings"},{"location":"get-started/configure-settings/#available-settings","text":"Group (C# class): Open Banking Connector Setting Example value Description \"SqliteDb ConnectionString\": \"Data Source=../../../../OpenBanking.Library. Connector/sqliteTestDb.db\" This string specifies the type of connection string being used. The path to the .db file will be specified. \"EnsureDbCreated\": \"true\" This settings identifies whether the database has been created. Group (C# class): Bank Profile Settings Setting Example value Description \"DataDirectory\":{ \"Windows\": Specified different OS types. \"Windows\": \"C:/Repos/open-banking-connector-csharp-data/bankProfileData\" Displays the specific path to the data directory for each OS.","title":"Available Settings"},{"location":"get-started/configure-settings/#configure-settings-for-a-plain-app-app-without-net-generic-host","text":"user has freedom to create settings in any way and use them when creating the Open Banking Connector request object. TODO: Need to set up setting providers for each settings group. (Bank Profile and Open Banking Connector)","title":"Configure settings for a \"Plain\" app (app without .NET Generic Host)"},{"location":"get-started/configure-settings/#configure-settings-for-net-generic-host-or-aspnet-core-app","text":"Microsoft ASP.NET Core is configured using various sources. One configuration method is the use of settings files such as appsettings.json. Please see Microsoft link for more information. The two setting groups can be used to create setting sections in appsettings.json or the settings can be set individually through the use of environment variables. For example: You could add the following to appsettings.json to configure the BankProfileSettings settings group. \"BankProfiles\" : { \"DataDirectory\" : { \"Windows\" : \"C:/Repos/open-banking-connector-csharp-data/bankProfileData\" , \"MacOs\" : \"~/Repos/open-banking-connector-csharp-data/bankProfileData\" , \"Linux\" : \"~/Repos/open-banking-connector-csharp-data/bankProfileData\" } } Refer to Microsoft link for more examples of how the C# code maps to the AppSettings file.","title":"Configure settings for .NET Generic Host or ASP.NET Core app"},{"location":"get-started/dev-environment/install-ob-root-cert/","text":"Install Open Banking Root Certificate An Open Banking UK root certificate needs to be installed to check remote certs from banks when creating SSL connections. Obtain the Root Certificate The UK Open Baking Sandbox root certificate can be obtained here . Currently only the Open Banking UK root certificate (and not the issuing certificate) needs to be installed. Install the Root Certificate On Windows, open the certificate manager (certlm.msc) and right-click \"Trusted Root Certification Authorities / Certificates\" and choose to import the certificate. On macOS (Big Sur), double-click the cert to add to the System Keychain and right-click to enable \"Always Trust\".","title":"Install OB Root Cerftificate"},{"location":"get-started/dev-environment/install-ob-root-cert/#install-open-banking-root-certificate","text":"An Open Banking UK root certificate needs to be installed to check remote certs from banks when creating SSL connections.","title":"Install Open Banking Root Certificate"},{"location":"get-started/dev-environment/install-ob-root-cert/#obtain-the-root-certificate","text":"The UK Open Baking Sandbox root certificate can be obtained here . Currently only the Open Banking UK root certificate (and not the issuing certificate) needs to be installed.","title":"Obtain the Root Certificate"},{"location":"get-started/dev-environment/install-ob-root-cert/#install-the-root-certificate","text":"On Windows, open the certificate manager (certlm.msc) and right-click \"Trusted Root Certification Authorities / Certificates\" and choose to import the certificate. On macOS (Big Sur), double-click the cert to add to the System Keychain and right-click to enable \"Always Trust\".","title":"Install the Root Certificate"},{"location":"how-to/set-up-software-statement-profiles/","text":"How to: Set up software statement profiles In UK Open Banking, a software statement is used to identify the entity (the \"TPP\") connecting to the bank. A software statement may for example may be created in the UK Open Banking directory. A software statement and associated information (keys, certificates, etc) are represented in Open Banking Connector (OBC) as a Software Statement Profile . The data that forms a software statement profile is shown below. Each bank registration is based on a software statment profile and so it is necessary to set one up before attempting to create a bank registration. Setting up a software statement profile is essentially a pre-requisite for use of OBC. Software statement profiles are provided to OBC via a secret provider as they contain very sensitive information. Although multiple software statement profiles can be provided, currently only one can be active (in use concurrently). We hope to relax this requirement in future. Development set-up and secrets structure For development purposes Microsoft's Secret Manager (i.e. a secrets.json file) can be used (see Microsoft's documentation for their Secrets Manager). The default UserSecretsId for OBC is currently specified in applicable .csproj files as: <UserSecretsId> aa921213-9461-4f9e-8fec-153624ec67ad </UserSecretsId> Basically to set things up with a secrets.json file you need to create a secrets folder with the name aa921213-9461-4f9e-8fec-153624ec67ad in the Microsoft UserSecrets folder for your platform and then place a secrets.json file for OBC there. Secrets used by OBC are always strings. Software statement profiles should be specified as secrets as shown in this example secrets.json file: { \"active-software-statement-profiles:profile-ids\" : \"0\" , \"software-statement-profile:0:signing-key-id\" : \"mySigningKeyId\" , \"software-statement-profile:0:signing-key\" : \"-----BEGIN PRIVATE KEY-----\\nmyKeyLine1\\nmyKeyLine2\\n-----END PRIVATE KEY-----\\n\" , \"software-statement-profile:0:signing-certificate\" : \"-----BEGIN CERTIFICATE-----\\nmyCertLine1\\nmyCertLine2\\n-----END CERTIFICATE-----\\n\" , \"software-statement-profile:0:transport-key\" : \"-----BEGIN PRIVATE KEY-----\\nmyKeyLine1\\nmyKeyLine2\\n-----END PRIVATE KEY-----\\n\" , \"software-statement-profile:0:transport-certificate\" : \"-----BEGIN CERTIFICATE-----\\nmyCertLine1\\nmyCertLine2\\n-----END CERTIFICATE-----\\n\" , \"software-statement-profile:0:software-statement\" : \"mySoftwareStatementPart1.mySoftwareStatementPart2.mySoftwareStatementPart3\" , \"software-statement-profile:0:default-fragment-redirect-url\" : \"https://example.com/auth/fragment-redirect\" , \"software-statement-profile:1:signing-key-id\" : \"mySigningKeyId\" , \"software-statement-profile:1:signing-key\" : \"-----BEGIN PRIVATE KEY-----\\nmyKeyLine1\\nmyKeyLine2\\n-----END PRIVATE KEY-----\\n\" , \"software-statement-profile:1:signing-certificate\" : \"-----BEGIN CERTIFICATE-----\\nmyCertLine1\\nmyCertLine2\\n-----END CERTIFICATE-----\\n\" , \"software-statement-profile:1:transport-key\" : \"-----BEGIN PRIVATE KEY-----\\nmyKeyLine1\\nmyKeyLine2\\n-----END PRIVATE KEY-----\\n\" , \"software-statement-profile:1:transport-certificate\" : \"-----BEGIN CERTIFICATE-----\\nmyCertLine1\\nmyCertLine2\\n-----END CERTIFICATE-----\\n\" , \"software-statement-profile:1:software-statement\" : \"mySoftwareStatementPart1.mySoftwareStatementPart2.mySoftwareStatementPart3\" , \"software-statement-profile:1:default-fragment-redirect-url\" : \"https://example.com/auth/fragment-redirect\" } Here two software statment profiles are specified (with IDs 0 and 1 ). active-software-statement-profiles:profile-ids must refer to the (for now single ) ID of a specified software statement (i.e. either 0 or 1 in the above example) and specifies which software statement profile is active. Any attempt to (a) use a non-active software statement profile when creating a bank registration in OBC, or (b) do anything based on a bank registration created with a non-active software statement in OBC will result in an error. Production set-up [TODO]","title":"How to"},{"location":"how-to/set-up-software-statement-profiles/#how-to-set-up-software-statement-profiles","text":"In UK Open Banking, a software statement is used to identify the entity (the \"TPP\") connecting to the bank. A software statement may for example may be created in the UK Open Banking directory. A software statement and associated information (keys, certificates, etc) are represented in Open Banking Connector (OBC) as a Software Statement Profile . The data that forms a software statement profile is shown below. Each bank registration is based on a software statment profile and so it is necessary to set one up before attempting to create a bank registration. Setting up a software statement profile is essentially a pre-requisite for use of OBC. Software statement profiles are provided to OBC via a secret provider as they contain very sensitive information. Although multiple software statement profiles can be provided, currently only one can be active (in use concurrently). We hope to relax this requirement in future.","title":"How to: Set up software statement profiles"},{"location":"how-to/set-up-software-statement-profiles/#development-set-up-and-secrets-structure","text":"For development purposes Microsoft's Secret Manager (i.e. a secrets.json file) can be used (see Microsoft's documentation for their Secrets Manager). The default UserSecretsId for OBC is currently specified in applicable .csproj files as: <UserSecretsId> aa921213-9461-4f9e-8fec-153624ec67ad </UserSecretsId> Basically to set things up with a secrets.json file you need to create a secrets folder with the name aa921213-9461-4f9e-8fec-153624ec67ad in the Microsoft UserSecrets folder for your platform and then place a secrets.json file for OBC there. Secrets used by OBC are always strings. Software statement profiles should be specified as secrets as shown in this example secrets.json file: { \"active-software-statement-profiles:profile-ids\" : \"0\" , \"software-statement-profile:0:signing-key-id\" : \"mySigningKeyId\" , \"software-statement-profile:0:signing-key\" : \"-----BEGIN PRIVATE KEY-----\\nmyKeyLine1\\nmyKeyLine2\\n-----END PRIVATE KEY-----\\n\" , \"software-statement-profile:0:signing-certificate\" : \"-----BEGIN CERTIFICATE-----\\nmyCertLine1\\nmyCertLine2\\n-----END CERTIFICATE-----\\n\" , \"software-statement-profile:0:transport-key\" : \"-----BEGIN PRIVATE KEY-----\\nmyKeyLine1\\nmyKeyLine2\\n-----END PRIVATE KEY-----\\n\" , \"software-statement-profile:0:transport-certificate\" : \"-----BEGIN CERTIFICATE-----\\nmyCertLine1\\nmyCertLine2\\n-----END CERTIFICATE-----\\n\" , \"software-statement-profile:0:software-statement\" : \"mySoftwareStatementPart1.mySoftwareStatementPart2.mySoftwareStatementPart3\" , \"software-statement-profile:0:default-fragment-redirect-url\" : \"https://example.com/auth/fragment-redirect\" , \"software-statement-profile:1:signing-key-id\" : \"mySigningKeyId\" , \"software-statement-profile:1:signing-key\" : \"-----BEGIN PRIVATE KEY-----\\nmyKeyLine1\\nmyKeyLine2\\n-----END PRIVATE KEY-----\\n\" , \"software-statement-profile:1:signing-certificate\" : \"-----BEGIN CERTIFICATE-----\\nmyCertLine1\\nmyCertLine2\\n-----END CERTIFICATE-----\\n\" , \"software-statement-profile:1:transport-key\" : \"-----BEGIN PRIVATE KEY-----\\nmyKeyLine1\\nmyKeyLine2\\n-----END PRIVATE KEY-----\\n\" , \"software-statement-profile:1:transport-certificate\" : \"-----BEGIN CERTIFICATE-----\\nmyCertLine1\\nmyCertLine2\\n-----END CERTIFICATE-----\\n\" , \"software-statement-profile:1:software-statement\" : \"mySoftwareStatementPart1.mySoftwareStatementPart2.mySoftwareStatementPart3\" , \"software-statement-profile:1:default-fragment-redirect-url\" : \"https://example.com/auth/fragment-redirect\" } Here two software statment profiles are specified (with IDs 0 and 1 ). active-software-statement-profiles:profile-ids must refer to the (for now single ) ID of a specified software statement (i.e. either 0 or 1 in the above example) and specifies which software statement profile is active. Any attempt to (a) use a non-active software statement profile when creating a bank registration in OBC, or (b) do anything based on a bank registration created with a non-active software statement in OBC will result in an error.","title":"Development set-up and secrets structure"},{"location":"how-to/set-up-software-statement-profiles/#production-set-up","text":"[TODO]","title":"Production set-up"},{"location":"interface/","text":"Interface Open Banking Connector is an in-process functional library providing abstract integration with banks. Our aim is to provide a simple, low-risk developer experience to help users make payments and access bank APIs as fast as possible. To this end we will make a DSL via standard C# fluent interface techniques. IRequestBuilder is an injectable .NET type that serves as the DSL's root object. As an example, take the following expression: var resp = await requestBuilder . Payment (). With ( ConsentInfo . FromJwt ( \"<some jwt>\" )) . For ( 123.43 ). Reference ( \"Your payment ref\" ) . From ( AccountInfo . Create ( \"01-02-03\" , \"12345677\" )) . To ( AccountInfo . Create ( \"Joe Bloggs\" , \"02-03-04\" , \"77665544\" )) . Submit (); This interface style is the facade that user code will use.","title":"Interface"},{"location":"interface/#interface","text":"Open Banking Connector is an in-process functional library providing abstract integration with banks. Our aim is to provide a simple, low-risk developer experience to help users make payments and access bank APIs as fast as possible. To this end we will make a DSL via standard C# fluent interface techniques. IRequestBuilder is an injectable .NET type that serves as the DSL's root object. As an example, take the following expression: var resp = await requestBuilder . Payment (). With ( ConsentInfo . FromJwt ( \"<some jwt>\" )) . For ( 123.43 ). Reference ( \"Your payment ref\" ) . From ( AccountInfo . Create ( \"01-02-03\" , \"12345677\" )) . To ( AccountInfo . Create ( \"Joe Bloggs\" , \"02-03-04\" , \"77665544\" )) . Submit (); This interface style is the facade that user code will use.","title":"Interface"},{"location":"interface/bank-configuration/","text":"Bank configuration The BankConfiguration interface allows you to create and read configuration for a bank in Open Banking Connector. The interface consists of three object types on which various methods are supported. Created objects correspond to records in the Open Banking Connector database. To set up a bank, you typically will create a Bank and at least one BankRegistration and one BankApiInformationObject object. More information is provided here . Interface object types The thee bank configuration object types are shown in the table below. Each corresponds to a table in the Open Banking Connector database. Two of the types are local-only and are not created externally at a bank. Objects of BankRegistration type, however, are created externally at a bank as well as having a local database record. Object type Parent type Created at bank? Description Bank N/A No Base object for a bank which includes its IssuerUrl and FinancialId BankApiInformationObject Bank No Object which describes a bank's functional APIs (e.g. PISP). Use multiple objects to allow access to multiple API versions supported by a bank (e.g. multiple versions of PISP), or to test new endpoints etc. BankReistration Bank Yes Object which describes a registration (i.e. OAuth2 client registration) with a bank based on a software statement. Use multiple objects to support multiple registrations with a bank or to test a new registration etc. Supported methods The table below shows the methods supported for each object type as well as the main request and response types for these methods. Methods that include the word \"Local\" operate on the Open Banking Connector database but not at the external bank. Object type Methods Request type Response type Bank GetLocalAsync PostLocalAsync DeleteLocalAsync Bank Bank BankRegistration PostAsync GetLocalAsync DeleteAsync BankRegistration BankRegistration BankApiInformation GetLocalAsyn PostLocalAsync DeleteLocalAsync BankApiInformation BankApiInformation","title":"Bank Configuration"},{"location":"interface/bank-configuration/#bank-configuration","text":"The BankConfiguration interface allows you to create and read configuration for a bank in Open Banking Connector. The interface consists of three object types on which various methods are supported. Created objects correspond to records in the Open Banking Connector database. To set up a bank, you typically will create a Bank and at least one BankRegistration and one BankApiInformationObject object. More information is provided here .","title":"Bank configuration"},{"location":"interface/bank-configuration/#interface-object-types","text":"The thee bank configuration object types are shown in the table below. Each corresponds to a table in the Open Banking Connector database. Two of the types are local-only and are not created externally at a bank. Objects of BankRegistration type, however, are created externally at a bank as well as having a local database record. Object type Parent type Created at bank? Description Bank N/A No Base object for a bank which includes its IssuerUrl and FinancialId BankApiInformationObject Bank No Object which describes a bank's functional APIs (e.g. PISP). Use multiple objects to allow access to multiple API versions supported by a bank (e.g. multiple versions of PISP), or to test new endpoints etc. BankReistration Bank Yes Object which describes a registration (i.e. OAuth2 client registration) with a bank based on a software statement. Use multiple objects to support multiple registrations with a bank or to test a new registration etc.","title":"Interface object types"},{"location":"interface/bank-configuration/#supported-methods","text":"The table below shows the methods supported for each object type as well as the main request and response types for these methods. Methods that include the word \"Local\" operate on the Open Banking Connector database but not at the external bank. Object type Methods Request type Response type Bank GetLocalAsync PostLocalAsync DeleteLocalAsync Bank Bank BankRegistration PostAsync GetLocalAsync DeleteAsync BankRegistration BankRegistration BankApiInformation GetLocalAsyn PostLocalAsync DeleteLocalAsync BankApiInformation BankApiInformation","title":"Supported methods"},{"location":"interface/bank-configuration/set-up-a-bank/","text":"Set up a bank To set up a bank, you need to create: a Bank object at least one BankRegistration object at least one BankApiInformationObject You can take advantage of Bank Profiles to generate request objects to use when creating these. Or you can use completely custom request objects. Example Here is an example of how to set up a bank using a Bank Profile and is based on code in the demo app . First we create a Bank object: // Create Bank request object from Bank Profile Bank bankRequest = bankProfile . BankRequest ( testNameUnique ); // Makes call to Open Banking Connector. Creates objectand stores in database. IFluentResponse < BankResponse > bankResp = await requestBuilder . ClientRegistration . Banks . PostLocalAsync ( bankRequest ); // Response from Open Banking Connector. Guid bankId = bankResp . Data !. Id ; Then we create a BankApiInfromationObject : // Create BankApiInformationObject request object from Bank Profile BankApiInformation apiInformationRequest = bankProfile . BankApiInformationRequest ( testNameUnique , bankId ); // Makes call to Open Banking Connector. Creates object and stores in database. IFluentResponse < BankApiInformationResponse > apiInformationResponse = await requestBuilder . ClientRegistration . BankApiInformationObjects . PostLocalAsync ( apiInformationRequest ); // Response from Open Banking Connector. Guid bankApiInformationId = apiInformationResponse . Data !. Id ; Finally, we create a BankRegistration object: // Create BankRegistration request object from Bank Profile BankRegistration registrationRequest = bankProfile . BankRegistrationRequest ( testNameUnique , bankId , softwareStatementProfileId , registrationScope ); // Makes call to Open Banking Connector. Creates object at bank and stores in database. IFluentResponse < BankRegistrationResponse > registrationResp = await requestBuilder . ClientRegistration . BankRegistrations . PostAsync ( registrationRequest ); // Response from Open Banking Connector. // Returns object with Unique ID. Guid bankRegistrationId = registrationResp . Data !. Id ; We now have set up a bank and are ready to access functional APIs (e.g. PISP).","title":"Setting up a bank"},{"location":"interface/bank-configuration/set-up-a-bank/#set-up-a-bank","text":"To set up a bank, you need to create: a Bank object at least one BankRegistration object at least one BankApiInformationObject You can take advantage of Bank Profiles to generate request objects to use when creating these. Or you can use completely custom request objects.","title":"Set up a bank"},{"location":"interface/bank-configuration/set-up-a-bank/#example","text":"Here is an example of how to set up a bank using a Bank Profile and is based on code in the demo app . First we create a Bank object: // Create Bank request object from Bank Profile Bank bankRequest = bankProfile . BankRequest ( testNameUnique ); // Makes call to Open Banking Connector. Creates objectand stores in database. IFluentResponse < BankResponse > bankResp = await requestBuilder . ClientRegistration . Banks . PostLocalAsync ( bankRequest ); // Response from Open Banking Connector. Guid bankId = bankResp . Data !. Id ; Then we create a BankApiInfromationObject : // Create BankApiInformationObject request object from Bank Profile BankApiInformation apiInformationRequest = bankProfile . BankApiInformationRequest ( testNameUnique , bankId ); // Makes call to Open Banking Connector. Creates object and stores in database. IFluentResponse < BankApiInformationResponse > apiInformationResponse = await requestBuilder . ClientRegistration . BankApiInformationObjects . PostLocalAsync ( apiInformationRequest ); // Response from Open Banking Connector. Guid bankApiInformationId = apiInformationResponse . Data !. Id ; Finally, we create a BankRegistration object: // Create BankRegistration request object from Bank Profile BankRegistration registrationRequest = bankProfile . BankRegistrationRequest ( testNameUnique , bankId , softwareStatementProfileId , registrationScope ); // Makes call to Open Banking Connector. Creates object at bank and stores in database. IFluentResponse < BankRegistrationResponse > registrationResp = await requestBuilder . ClientRegistration . BankRegistrations . PostAsync ( registrationRequest ); // Response from Open Banking Connector. // Returns object with Unique ID. Guid bankRegistrationId = registrationResp . Data !. Id ; We now have set up a bank and are ready to access functional APIs (e.g. PISP).","title":"Example"},{"location":"interface/payment-initiation/","text":"Payment Initiation The PaymentInitiation interface allows you to create and read bank payments in Open Banking Connector. It is based on v3.1.6 of the UK Open Banking Read-Write Payment Initiation API . Please see here for more information on supported APIs. The functionality of the interface is described in the following pages: domestic paymnents","title":"Payment Intiation"},{"location":"interface/payment-initiation/#payment-initiation","text":"The PaymentInitiation interface allows you to create and read bank payments in Open Banking Connector. It is based on v3.1.6 of the UK Open Banking Read-Write Payment Initiation API . Please see here for more information on supported APIs. The functionality of the interface is described in the following pages: domestic paymnents","title":"Payment Initiation"},{"location":"interface/payment-initiation/create-and-authorise-domestic-payment-consent/","text":"Create and Authorise domestic payment consent To set up domestic payment consent, you need to: create a DomesticPaymentConsent [optional] check for funds confirmation create an AuthContext which generates an auth URL let the user authorise the consent using the URL which will generate a redirect either (a) use Open Banking Connector to process the redirect (b) use external software to process the redirect and pass the results to Open Banking Connector Example Here is an example of how to set up the domestic payment consent. The example is based on code in the demo app . First, we create a domenstic payment consent object: // Create domestic payment consent DomesticPaymentConsent domesticPaymentConsentRequest = bankProfile . DomesticPaymentConsentRequest ( bankRegistrationId , bankApiInformationId , DomesticPaymentTypeEnum . PersonToMerchant , Guid . NewGuid (). ToString ( \"N\" ), Guid . NewGuid (). ToString ( \"N\" ), testNameUnique ); // Makes call to Open Banking Connector. Creates objectand stores in database. IFluentResponse < DomesticPaymentConsentResponse > domesticPaymentConsentResp = await requestBuilder . PaymentInitiation . DomesticPaymentConsents . PostAsync ( domesticPaymentConsentRequest ); // Response from Open Banking Connector. Guid domesticPaymentConsentId = domesticPaymentConsentResp . Data !. Id ; Next, get the Domestic Payment Consent Funds Confirmation // GET consent funds confirmation // Makes call to Open Banking Connector. Creates objectand stores in database. IFluentResponse < DomesticPaymentConsentResponse > domesticPaymentConsentResp4 = await requestBuilderNew . PaymentInitiation . DomesticPaymentConsents . GetFundsConfirmationAsync ( domesticPaymentConsentId ); Then, create the Auth Context // POST auth context var authContextRequest = new DomesticPaymentConsentAuthContext { DomesticPaymentConsentId = domesticPaymentConsentId , Name = testNameUnique }; // Makes call to Open Banking Connector. Creates objectand stores in database. IFluentResponse < DomesticPaymentConsentAuthContextPostResponse > authContextResponse = await requestBuilder . PaymentInitiation . DomesticPaymentConsents . AuthContexts . PostLocalAsync ( authContextRequest ); Once a DomesticPaymentConsent has been created and authorised, a domestic payment may be made .","title":"Create and authorise Domestic Payment Consent"},{"location":"interface/payment-initiation/create-and-authorise-domestic-payment-consent/#create-and-authorise-domestic-payment-consent","text":"To set up domestic payment consent, you need to: create a DomesticPaymentConsent [optional] check for funds confirmation create an AuthContext which generates an auth URL let the user authorise the consent using the URL which will generate a redirect either (a) use Open Banking Connector to process the redirect (b) use external software to process the redirect and pass the results to Open Banking Connector","title":"Create and Authorise domestic payment consent"},{"location":"interface/payment-initiation/create-and-authorise-domestic-payment-consent/#example","text":"Here is an example of how to set up the domestic payment consent. The example is based on code in the demo app . First, we create a domenstic payment consent object: // Create domestic payment consent DomesticPaymentConsent domesticPaymentConsentRequest = bankProfile . DomesticPaymentConsentRequest ( bankRegistrationId , bankApiInformationId , DomesticPaymentTypeEnum . PersonToMerchant , Guid . NewGuid (). ToString ( \"N\" ), Guid . NewGuid (). ToString ( \"N\" ), testNameUnique ); // Makes call to Open Banking Connector. Creates objectand stores in database. IFluentResponse < DomesticPaymentConsentResponse > domesticPaymentConsentResp = await requestBuilder . PaymentInitiation . DomesticPaymentConsents . PostAsync ( domesticPaymentConsentRequest ); // Response from Open Banking Connector. Guid domesticPaymentConsentId = domesticPaymentConsentResp . Data !. Id ; Next, get the Domestic Payment Consent Funds Confirmation // GET consent funds confirmation // Makes call to Open Banking Connector. Creates objectand stores in database. IFluentResponse < DomesticPaymentConsentResponse > domesticPaymentConsentResp4 = await requestBuilderNew . PaymentInitiation . DomesticPaymentConsents . GetFundsConfirmationAsync ( domesticPaymentConsentId ); Then, create the Auth Context // POST auth context var authContextRequest = new DomesticPaymentConsentAuthContext { DomesticPaymentConsentId = domesticPaymentConsentId , Name = testNameUnique }; // Makes call to Open Banking Connector. Creates objectand stores in database. IFluentResponse < DomesticPaymentConsentAuthContextPostResponse > authContextResponse = await requestBuilder . PaymentInitiation . DomesticPaymentConsents . AuthContexts . PostLocalAsync ( authContextRequest ); Once a DomesticPaymentConsent has been created and authorised, a domestic payment may be made .","title":"Example"},{"location":"interface/payment-initiation/domestic-payments/","text":"Domestic Payments The Payment Initiation API supports creating and reading domestic payments. Interface object types The three domestic payment object types are shown in the table below. Each corresponds to a table in the Open Banking Connector database. Object type Parent type(s) Created at bank? Description DomesticPayment Consents BankRegistration , BankApiSet Yes Object a user can \"authorise\" to consent to a payment authorisation a domestic payment. DomesticPayments DomesticPaymentConsent Yes Payment object AuthContexts DomesticPaymentConsent No Object which represents a session allowing the user to authorise a consent Supported methods The table below shows the methods supported for each object type as well as the main request and response types for these methods. Methods that include the word \"Local\" operate on the Open Banking Connector database but not at the external bank. Object type Methods Request type Response type DomesticPaymentConsents GetLocalAsync PostAsync DeleteLocalAsync GetAsync GetFundsConfirmationAsync Consent Consent DomesticPayments GetAsync PostAsync GetLocalAsync DeleteAsync Payment Payment AuthContexts Auth Auth","title":"Domestic Payments"},{"location":"interface/payment-initiation/domestic-payments/#domestic-payments","text":"The Payment Initiation API supports creating and reading domestic payments.","title":"Domestic Payments"},{"location":"interface/payment-initiation/domestic-payments/#interface-object-types","text":"The three domestic payment object types are shown in the table below. Each corresponds to a table in the Open Banking Connector database. Object type Parent type(s) Created at bank? Description DomesticPayment Consents BankRegistration , BankApiSet Yes Object a user can \"authorise\" to consent to a payment authorisation a domestic payment. DomesticPayments DomesticPaymentConsent Yes Payment object AuthContexts DomesticPaymentConsent No Object which represents a session allowing the user to authorise a consent","title":"Interface object types"},{"location":"interface/payment-initiation/domestic-payments/#supported-methods","text":"The table below shows the methods supported for each object type as well as the main request and response types for these methods. Methods that include the word \"Local\" operate on the Open Banking Connector database but not at the external bank. Object type Methods Request type Response type DomesticPaymentConsents GetLocalAsync PostAsync DeleteLocalAsync GetAsync GetFundsConfirmationAsync Consent Consent DomesticPayments GetAsync PostAsync GetLocalAsync DeleteAsync Payment Payment AuthContexts Auth Auth","title":"Supported methods"},{"location":"interface/payment-initiation/make-domestic-payment/","text":"Make Domestic Payment Before making a domestic payment you need to create and authorise a domestic payment consent. You can then make a domestic payment by: using the PostAsync method on requestBuilder.PaymentInitiation.DomesticPayments Example This is an example of how to make a domestic payment. We here create a request object for the domestic payment based on the previously created request object for the domestic payment consent . The required inputs are: domesticPaymentConsentRequest : the consent request object domesticPaymentConsentId : the consent ID testNameUnique : the name field for the payment // Create domestic payment request requestBuilder . Utility . Map ( domesticPaymentConsentRequest . OBWriteDomesticConsent , out PaymentInitiationModelsPublic . OBWriteDomestic2 obWriteDomestic ); // maps Open Banking request objects DomesticPayment domesticPaymentRequest = new DomesticPayment { OBWriteDomestic = obWriteDomestic , DomesticPaymentConsentId = domesticPaymentConsentId , Name = testNameUnique }; // POST domestic payment IFluentResponse < DomesticPaymentResponse > domesticPaymentResponse = await requestBuilder . PaymentInitiation . DomesticPayments . PostAsync ( domesticPaymentRequest ); Guid domesticPaymentId = domesticPaymentResponse . Data !. Id ;","title":"Make Domestic Payments"},{"location":"interface/payment-initiation/make-domestic-payment/#make-domestic-payment","text":"Before making a domestic payment you need to create and authorise a domestic payment consent. You can then make a domestic payment by: using the PostAsync method on requestBuilder.PaymentInitiation.DomesticPayments","title":"Make Domestic Payment"},{"location":"interface/payment-initiation/make-domestic-payment/#example","text":"This is an example of how to make a domestic payment. We here create a request object for the domestic payment based on the previously created request object for the domestic payment consent . The required inputs are: domesticPaymentConsentRequest : the consent request object domesticPaymentConsentId : the consent ID testNameUnique : the name field for the payment // Create domestic payment request requestBuilder . Utility . Map ( domesticPaymentConsentRequest . OBWriteDomesticConsent , out PaymentInitiationModelsPublic . OBWriteDomestic2 obWriteDomestic ); // maps Open Banking request objects DomesticPayment domesticPaymentRequest = new DomesticPayment { OBWriteDomestic = obWriteDomestic , DomesticPaymentConsentId = domesticPaymentConsentId , Name = testNameUnique }; // POST domestic payment IFluentResponse < DomesticPaymentResponse > domesticPaymentResponse = await requestBuilder . PaymentInitiation . DomesticPayments . PostAsync ( domesticPaymentRequest ); Guid domesticPaymentId = domesticPaymentResponse . Data !. Id ;","title":"Example"},{"location":"interface/variable-recurring-payments/","text":"Variable Recurring Payments The VariableRecurringPayments interface allows you to create and read variable recurring bank payments in Open Banking Connector. It is based on v3.1.8 of the UK Open Banking Read-Write Variable Recurring Payments API . The functionality of the interface is described in the following pages: - variable recurring payments","title":"Variable Recurring Payments"},{"location":"interface/variable-recurring-payments/#variable-recurring-payments","text":"The VariableRecurringPayments interface allows you to create and read variable recurring bank payments in Open Banking Connector. It is based on v3.1.8 of the UK Open Banking Read-Write Variable Recurring Payments API . The functionality of the interface is described in the following pages: - variable recurring payments","title":"Variable Recurring Payments"},{"location":"interface/variable-recurring-payments/create-and-authorise-domestic-vrp-consent/","text":"Create and Authorise domestic vrp consent To set up domestic vrp consent, you need to: create a DomesticVrpConsent [optional] check for funds confirmation create an AuthContext which generates an auth URL let the user authorise the consent using the URL which will generate a redirect either (a) use Open Banking Connector to process the redirect (b) use external software to process the redirect and pass the results to Open Banking Connector Example Here is an example of how to set up the domestic vrp consent. The example is based on code in the demo app . First, we create a domestic vrp consent object: // Create domestic VRP consent DomesticVrpConsent domesticVrpConsentRequest = bankProfile . DomesticVrpConsentRequest ( bankRegistrationId , bankApiSetId , domesticVrpTypeEnum , testNameUnique ); // Makes call to Open Banking Connector. Creates objectand stores in database. IFluentResponse < DomesticVrpConsentResponse > domesticVrpConsentResponse = await requestBuilder . VariableRecurringPayments . DomesticVrpConsents . PostAsync ( domesticVrpConsentRequest ); // Response from Open Banking Connector. Guid domesticVrpConsentId = domesticVrpConsentResponse . Data !. Id ; Next, get the Domestic Vrp Consent Funds Confirmation: // GET consent funds confirmation // Makes call to Open Banking Connector. Creates objectand stores in database. IFluentResponse < DomesticVrpConsentResponse > domesticPaymentConsentResp4 = await requestBuilderNew . VariableRecurringPayments . DomesticVrpConsents . GetFundsConfirmationAsync ( domesticVrpConsentId ); Then, create the Auth Context: // POST auth context var authContextRequest = new DomesticVrpConsentAuthContext { DomesticVrpConsentId = domesticVrpConsentId , Name = testNameUnique }; IFluentResponse < DomesticVrpConsentAuthContextPostResponse > authContextResponse = await requestBuilder . VariableRecurringPayments . DomesticVrpConsents . AuthContexts . PostLocalAsync ( authContextRequest ); Once a DomesticPaymentConsent has been created and authorised, a domestic payment may be made .","title":"Create and authorise Domestic VRP Consent"},{"location":"interface/variable-recurring-payments/create-and-authorise-domestic-vrp-consent/#create-and-authorise-domestic-vrp-consent","text":"To set up domestic vrp consent, you need to: create a DomesticVrpConsent [optional] check for funds confirmation create an AuthContext which generates an auth URL let the user authorise the consent using the URL which will generate a redirect either (a) use Open Banking Connector to process the redirect (b) use external software to process the redirect and pass the results to Open Banking Connector","title":"Create and Authorise domestic vrp consent"},{"location":"interface/variable-recurring-payments/create-and-authorise-domestic-vrp-consent/#example","text":"Here is an example of how to set up the domestic vrp consent. The example is based on code in the demo app . First, we create a domestic vrp consent object: // Create domestic VRP consent DomesticVrpConsent domesticVrpConsentRequest = bankProfile . DomesticVrpConsentRequest ( bankRegistrationId , bankApiSetId , domesticVrpTypeEnum , testNameUnique ); // Makes call to Open Banking Connector. Creates objectand stores in database. IFluentResponse < DomesticVrpConsentResponse > domesticVrpConsentResponse = await requestBuilder . VariableRecurringPayments . DomesticVrpConsents . PostAsync ( domesticVrpConsentRequest ); // Response from Open Banking Connector. Guid domesticVrpConsentId = domesticVrpConsentResponse . Data !. Id ; Next, get the Domestic Vrp Consent Funds Confirmation: // GET consent funds confirmation // Makes call to Open Banking Connector. Creates objectand stores in database. IFluentResponse < DomesticVrpConsentResponse > domesticPaymentConsentResp4 = await requestBuilderNew . VariableRecurringPayments . DomesticVrpConsents . GetFundsConfirmationAsync ( domesticVrpConsentId ); Then, create the Auth Context: // POST auth context var authContextRequest = new DomesticVrpConsentAuthContext { DomesticVrpConsentId = domesticVrpConsentId , Name = testNameUnique }; IFluentResponse < DomesticVrpConsentAuthContextPostResponse > authContextResponse = await requestBuilder . VariableRecurringPayments . DomesticVrpConsents . AuthContexts . PostLocalAsync ( authContextRequest ); Once a DomesticPaymentConsent has been created and authorised, a domestic payment may be made .","title":"Example"},{"location":"interface/variable-recurring-payments/domestic-vrps/","text":"Variable Recurring Payments Payment object types The thee payment configuration object types are shown in the table below. Each corresponds to a table in the Open Banking Connector database. Object type Parent type(s) Created at bank? Description DomesticVrp Consents BankRegistration , BankApiSet Yes Object a user can \"authorise\" to consent to a payment authorisation a variable recurring payment. DomesticVrp DomesticVrpConsent Yes Payment object AuthContexts DomesticVrpConsent No Object which represents a session allowing the user to authorise a consent Supported methods The table below shows the methods supported for each object type as well as the main request and response types for these methods. Methods that include the word \"Local\" operate on the Open Banking Connector database but not at the external bank. Object type Methods Request type Response type DomesticVrpConsents GetLocalAsync PostAsync DeleteLocalAsync GetAsync GetFundsConfirmationAsync Consent Consent DomesticPayments GetAsync PostAsync GetLocalAsync DeleteAsync Payment Payment AuthContexts Auth Auth","title":"Domestic VRP"},{"location":"interface/variable-recurring-payments/domestic-vrps/#variable-recurring-payments","text":"","title":"Variable Recurring Payments"},{"location":"interface/variable-recurring-payments/domestic-vrps/#payment-object-types","text":"The thee payment configuration object types are shown in the table below. Each corresponds to a table in the Open Banking Connector database. Object type Parent type(s) Created at bank? Description DomesticVrp Consents BankRegistration , BankApiSet Yes Object a user can \"authorise\" to consent to a payment authorisation a variable recurring payment. DomesticVrp DomesticVrpConsent Yes Payment object AuthContexts DomesticVrpConsent No Object which represents a session allowing the user to authorise a consent","title":"Payment object types"},{"location":"interface/variable-recurring-payments/domestic-vrps/#supported-methods","text":"The table below shows the methods supported for each object type as well as the main request and response types for these methods. Methods that include the word \"Local\" operate on the Open Banking Connector database but not at the external bank. Object type Methods Request type Response type DomesticVrpConsents GetLocalAsync PostAsync DeleteLocalAsync GetAsync GetFundsConfirmationAsync Consent Consent DomesticPayments GetAsync PostAsync GetLocalAsync DeleteAsync Payment Payment AuthContexts Auth Auth","title":"Supported methods"},{"location":"interface/variable-recurring-payments/make-domestic-vrps/","text":"Make Variable Recurring Payments Before making a variable recurring payment you must have created and authorised a consent. You can then make a variable recurring payment by: creating a VariableRecurringPayment reading the VariableRecurringPayment to check its status. using the PostAsync method on requestBuilder.VariableRecurringPayment.DomesticVrpPayments Example Here is an example of how to make a variable recurring payment. We create a domestic vrp request object based on a previously created domestic vrp consent request object. The required inputs are: domesticVrpConsentRequest : the consent request object domesticVrpConsentId : the consent ID testNameUnique : the name field for the payment // Create domestic vrp request requestBuilder . Utility . Map ( domesticVrpConsentRequest . OBDomesticVRPConsentRequest , out VariableRecurringPaymentsModelsPublic . OBDomesticVRPRequest obDomesticVrpRequest ); // maps Open Banking request objects DomesticVrp domesticVrpRequest = new DomesticVrp { OBDomesticVRPRequest = obDomesticVrpRequest , Name = testNameUnique , DomesticVrpConsentId = domesticVrpConsentId , }; // POST domestic VRP IFluentResponse < DomesticVrpResponse > domesticVrpResponse = await requestBuilder . VariableRecurringPayments . DomesticVrps . PostAsync ( domesticVrpRequest ); // Response from Open Banking Connector. Guid domesticVrpId = domesticVrpResponse . Data !. Id ;","title":"Make Domestic VRP"},{"location":"interface/variable-recurring-payments/make-domestic-vrps/#make-variable-recurring-payments","text":"Before making a variable recurring payment you must have created and authorised a consent. You can then make a variable recurring payment by: creating a VariableRecurringPayment reading the VariableRecurringPayment to check its status. using the PostAsync method on requestBuilder.VariableRecurringPayment.DomesticVrpPayments","title":"Make Variable Recurring Payments"},{"location":"interface/variable-recurring-payments/make-domestic-vrps/#example","text":"Here is an example of how to make a variable recurring payment. We create a domestic vrp request object based on a previously created domestic vrp consent request object. The required inputs are: domesticVrpConsentRequest : the consent request object domesticVrpConsentId : the consent ID testNameUnique : the name field for the payment // Create domestic vrp request requestBuilder . Utility . Map ( domesticVrpConsentRequest . OBDomesticVRPConsentRequest , out VariableRecurringPaymentsModelsPublic . OBDomesticVRPRequest obDomesticVrpRequest ); // maps Open Banking request objects DomesticVrp domesticVrpRequest = new DomesticVrp { OBDomesticVRPRequest = obDomesticVrpRequest , Name = testNameUnique , DomesticVrpConsentId = domesticVrpConsentId , }; // POST domestic VRP IFluentResponse < DomesticVrpResponse > domesticVrpResponse = await requestBuilder . VariableRecurringPayments . DomesticVrps . PostAsync ( domesticVrpRequest ); // Response from Open Banking Connector. Guid domesticVrpId = domesticVrpResponse . Data !. Id ;","title":"Example"},{"location":"overview/","text":"Overview Introduction Open Banking Connector is open-source software that manages and simplifies connections to UK Open Banking APIs. Its core is a collection of C# class libraries provided as packages in Nuget . It is designed for use with modern C# applications including \"plain\" apps (those without a .NET Generic Host ) and .NET Generic Host-based/ASP.NET Core apps. Its main purposes are: - to manage security aspects of Open Banking API accesses including registrations and tokens - to absorb bank differences including API version differences and behavioural/implementation differences so as much as possible the same API calls may be used for all banks It is currently focussed on support for domestic payments in UK Open Banking but has been designed for future extension to all UK Open Banking APIs. Uses Open Banking Connector can be used: as a connection layer allowing .NET backend software to connect to UK banks as a reference platform for creating and managing bank registrations used by other software. as a standalone bank test suite. Its built-in bank tests test Open Banking APIs in UK bank sandboxes and include a consent authoriser that automates web page user consent. To support the above, Open Banking Connector contains Bank Profiles for UK banks which provide reference configurations as used in the bank tests. Anyone is invited to contribute and update these profiles to extend the bank coverage of OBC and increase the value of this resource. Compatibility Open Banking Connector is a set of .NET Core libraries. They either target .NET Standard 2.1 or .NET Core 3.1, i.e. the current .NET Core LTS release. Going forward, we plan to evolve the master branch of Open Banking Connector (where active development takes place) to track the current LTS version of .NET approximately six months after release. Hence the next planned update is to .NET 6 approximately six months after its release. Open Banking Connector is designed to run in the cloud as part of two kinds of .NET app: - Apps based on .NET Generic Host (which may or may not be web apps but utilise features such as DI and Configuration) - Apps not based on .NET Generic Host (\"plain apps\") It requires both a relational database and key secret vault. We use EF Core for database access and test locally using SQLite. We use the local Secret Manager as a key vault for local testing. We have designed OBC to enable DB and key secret support on all main cloud platforms and are currently preparing to test on Azure using Azure Key Vault and Azure SQL. Interface Open Banking Connector provides an intuitive, Fluent REST-inspired interface. The idea is to have a single, standardised interface that works with multiple banks. More information may be found here . Open Banking API support Open Banking Connector supports multiple Open Banking APIs (depends on bank support) and provides a Fluent interface based on the latest supported version. More information may be found here . Documentation This documentation is available both in the GitHub repo and on the docs website . The documentation is divided into the following sections: Getting Started Architecture Client Interface How-to To generate the docs website based on the contents of a local open-banking-connector repo (i.e. latest edits), you will need to install Python 3 and Material for MkDocs (mkdocs-material). Assuming you have installed Python, you can install Material for MkDocs as follows: pip install mkdocs-material # if mkdocs-material not installed To deploy the website locally for inspection and testing, please cd to the OBC repo root and run the following command: mkdocs serve This will return the URL you can use to see the website. If you have permissions, you can update the public website on GitHub Pages using mkdocs gh-deploy -m \"Test deployment\" -r publicRemote # adjust commit message and remote as required","title":"Overview"},{"location":"overview/#overview","text":"","title":"Overview"},{"location":"overview/#introduction","text":"Open Banking Connector is open-source software that manages and simplifies connections to UK Open Banking APIs. Its core is a collection of C# class libraries provided as packages in Nuget . It is designed for use with modern C# applications including \"plain\" apps (those without a .NET Generic Host ) and .NET Generic Host-based/ASP.NET Core apps. Its main purposes are: - to manage security aspects of Open Banking API accesses including registrations and tokens - to absorb bank differences including API version differences and behavioural/implementation differences so as much as possible the same API calls may be used for all banks It is currently focussed on support for domestic payments in UK Open Banking but has been designed for future extension to all UK Open Banking APIs.","title":"Introduction"},{"location":"overview/#uses","text":"Open Banking Connector can be used: as a connection layer allowing .NET backend software to connect to UK banks as a reference platform for creating and managing bank registrations used by other software. as a standalone bank test suite. Its built-in bank tests test Open Banking APIs in UK bank sandboxes and include a consent authoriser that automates web page user consent. To support the above, Open Banking Connector contains Bank Profiles for UK banks which provide reference configurations as used in the bank tests. Anyone is invited to contribute and update these profiles to extend the bank coverage of OBC and increase the value of this resource.","title":"Uses"},{"location":"overview/#compatibility","text":"Open Banking Connector is a set of .NET Core libraries. They either target .NET Standard 2.1 or .NET Core 3.1, i.e. the current .NET Core LTS release. Going forward, we plan to evolve the master branch of Open Banking Connector (where active development takes place) to track the current LTS version of .NET approximately six months after release. Hence the next planned update is to .NET 6 approximately six months after its release. Open Banking Connector is designed to run in the cloud as part of two kinds of .NET app: - Apps based on .NET Generic Host (which may or may not be web apps but utilise features such as DI and Configuration) - Apps not based on .NET Generic Host (\"plain apps\") It requires both a relational database and key secret vault. We use EF Core for database access and test locally using SQLite. We use the local Secret Manager as a key vault for local testing. We have designed OBC to enable DB and key secret support on all main cloud platforms and are currently preparing to test on Azure using Azure Key Vault and Azure SQL.","title":"Compatibility"},{"location":"overview/#interface","text":"Open Banking Connector provides an intuitive, Fluent REST-inspired interface. The idea is to have a single, standardised interface that works with multiple banks. More information may be found here .","title":"Interface"},{"location":"overview/#open-banking-api-support","text":"Open Banking Connector supports multiple Open Banking APIs (depends on bank support) and provides a Fluent interface based on the latest supported version. More information may be found here .","title":"Open Banking API support"},{"location":"overview/#documentation","text":"This documentation is available both in the GitHub repo and on the docs website . The documentation is divided into the following sections: Getting Started Architecture Client Interface How-to To generate the docs website based on the contents of a local open-banking-connector repo (i.e. latest edits), you will need to install Python 3 and Material for MkDocs (mkdocs-material). Assuming you have installed Python, you can install Material for MkDocs as follows: pip install mkdocs-material # if mkdocs-material not installed To deploy the website locally for inspection and testing, please cd to the OBC repo root and run the following command: mkdocs serve This will return the URL you can use to see the website. If you have permissions, you can update the public website on GitHub Pages using mkdocs gh-deploy -m \"Test deployment\" -r publicRemote # adjust commit message and remote as required","title":"Documentation"}]}