{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-\\.]"},"docs":[{"location":"","text":"Overview Introduction Open Banking Connector is open-source software that manages and simplifies connections to UK Open Banking APIs. Its core is a collection of C# class libraries provided as packages in Nuget . It is designed for use with modern C# applications including \"plain\" apps (those without a .NET Generic Host ) and .NET Generic Host-based/ASP.NET Core apps. Its main purposes are: - to manage security aspects of Open Banking API accesses including registrations and tokens - to absorb bank differences including API version differences and behavioural/implementation differences so as much as possible the same API calls may be used for all banks It is currently focussed on support for domestic payments in UK Open Banking but has been designed for future extension to all UK Open Banking APIs. Uses Open Banking Connector can be used: as a connection layer allowing .NET backend software to connect to UK banks as a reference platform for creating and managing bank registrations used by other software. as a standalone bank test suite. Its built-in bank tests test Open Banking APIs in UK bank sandboxes and include a consent authoriser that automates web page user consent. To support the above, Open Banking Connector contains Bank Profiles for UK banks which provide reference configurations as used in the bank tests. Anyone is invited to contribute and update these profiles to extend the bank coverage of OBC and increase the value of this resource. Compatibility Open Banking Connector is a set of .NET Core libraries. They either target .NET Standard 2.1 or .NET Core 3.1, i.e. the current .NET Core LTS release. Going forward, we plan to evolve the master branch of Open Banking Connector (where active development takes place) to track the current LTS version of .NET approximately six months after release. Hence the next planned update is to .NET 6 approximately six months after its release. Open Banking Connector is designed to run in the cloud as part of two kinds of .NET app: - Apps based on .NET Generic Host (which may or may not be web apps but utilise features such as DI and Configuration) - Apps not based on .NET Generic Host (\"plain apps\") It requires both a relational database and key secret vault. We use EF Core for database access and test locally using SQLite. We use the local Secret Manager as a key vault for local testing. We have designed OBC to enable DB and key secret support on all main cloud platforms and are currently preparing to test on Azure using Azure Key Vault and Azure SQL. Interface Open Banking Connector provides an intuitive, Fluent REST-inspired interface. The idea is to have a single, standardised interface that works with multiple banks. More information may be found here . Open Banking API support Open Banking Connector supports multiple Open Banking APIs (depends on bank support) and provides a Fluent interface based on the latest supported version. More information may be found here . Documentation This documentation is available both in the GitHub repo and on the docs website . Please raise a github issue if you experience any problems or have any feedback. The documentation is divided into the following sections: Getting Started How to Client Interface Architecture Contributor Info","title":"Overview"},{"location":"#overview","text":"","title":"Overview"},{"location":"#introduction","text":"Open Banking Connector is open-source software that manages and simplifies connections to UK Open Banking APIs. Its core is a collection of C# class libraries provided as packages in Nuget . It is designed for use with modern C# applications including \"plain\" apps (those without a .NET Generic Host ) and .NET Generic Host-based/ASP.NET Core apps. Its main purposes are: - to manage security aspects of Open Banking API accesses including registrations and tokens - to absorb bank differences including API version differences and behavioural/implementation differences so as much as possible the same API calls may be used for all banks It is currently focussed on support for domestic payments in UK Open Banking but has been designed for future extension to all UK Open Banking APIs.","title":"Introduction"},{"location":"#uses","text":"Open Banking Connector can be used: as a connection layer allowing .NET backend software to connect to UK banks as a reference platform for creating and managing bank registrations used by other software. as a standalone bank test suite. Its built-in bank tests test Open Banking APIs in UK bank sandboxes and include a consent authoriser that automates web page user consent. To support the above, Open Banking Connector contains Bank Profiles for UK banks which provide reference configurations as used in the bank tests. Anyone is invited to contribute and update these profiles to extend the bank coverage of OBC and increase the value of this resource.","title":"Uses"},{"location":"#compatibility","text":"Open Banking Connector is a set of .NET Core libraries. They either target .NET Standard 2.1 or .NET Core 3.1, i.e. the current .NET Core LTS release. Going forward, we plan to evolve the master branch of Open Banking Connector (where active development takes place) to track the current LTS version of .NET approximately six months after release. Hence the next planned update is to .NET 6 approximately six months after its release. Open Banking Connector is designed to run in the cloud as part of two kinds of .NET app: - Apps based on .NET Generic Host (which may or may not be web apps but utilise features such as DI and Configuration) - Apps not based on .NET Generic Host (\"plain apps\") It requires both a relational database and key secret vault. We use EF Core for database access and test locally using SQLite. We use the local Secret Manager as a key vault for local testing. We have designed OBC to enable DB and key secret support on all main cloud platforms and are currently preparing to test on Azure using Azure Key Vault and Azure SQL.","title":"Compatibility"},{"location":"#interface","text":"Open Banking Connector provides an intuitive, Fluent REST-inspired interface. The idea is to have a single, standardised interface that works with multiple banks. More information may be found here .","title":"Interface"},{"location":"#open-banking-api-support","text":"Open Banking Connector supports multiple Open Banking APIs (depends on bank support) and provides a Fluent interface based on the latest supported version. More information may be found here .","title":"Open Banking API support"},{"location":"#documentation","text":"This documentation is available both in the GitHub repo and on the docs website . Please raise a github issue if you experience any problems or have any feedback. The documentation is divided into the following sections: Getting Started How to Client Interface Architecture Contributor Info","title":"Documentation"},{"location":"definitions/","text":"Definitions This page provides defintions for commonly used terms in Open Banking Connector. Software Statement Profile In UK Open Banking, a software statement is used to identify the entity (the \"TPP\") connecting to a bank. A software statement may be created in the UK Open Banking directory. A software statement and associated information are represented in Open Banking Connector as a Software Statement Profile . Each bank registration is based on a software statment profile and so it is necessary to set one up before attempting to create a bank registration. Software statement profiles are provided to Open Banking Connector as key secrets. OB Certificate Profile UK Open Banking uses certificates for signing and transport. In Open Banking Connector, information relating to a signing certificate and transport certificate pair is grouped together in an OB Certificate Profile . Software statement profiles are provided to Open Banking Connector as key secrets. Payment Initiation In UK Open Banking, the term Payment Initiation refers to an API which allows customers to authorise single payments directly from their bank accounts. Variable Recurring Payments Variable Recurring Payments refers to an API which allows third party companies (such as money management apps) to authorise recurring payments from the customer's bank account to the merchants bank account.","title":"Definitions"},{"location":"definitions/#definitions","text":"This page provides defintions for commonly used terms in Open Banking Connector.","title":"Definitions"},{"location":"definitions/#software-statement-profile","text":"In UK Open Banking, a software statement is used to identify the entity (the \"TPP\") connecting to a bank. A software statement may be created in the UK Open Banking directory. A software statement and associated information are represented in Open Banking Connector as a Software Statement Profile . Each bank registration is based on a software statment profile and so it is necessary to set one up before attempting to create a bank registration. Software statement profiles are provided to Open Banking Connector as key secrets.","title":"Software Statement Profile"},{"location":"definitions/#ob-certificate-profile","text":"UK Open Banking uses certificates for signing and transport. In Open Banking Connector, information relating to a signing certificate and transport certificate pair is grouped together in an OB Certificate Profile . Software statement profiles are provided to Open Banking Connector as key secrets.","title":"OB Certificate Profile"},{"location":"definitions/#payment-initiation","text":"In UK Open Banking, the term Payment Initiation refers to an API which allows customers to authorise single payments directly from their bank accounts.","title":"Payment Initiation"},{"location":"definitions/#variable-recurring-payments","text":"Variable Recurring Payments refers to an API which allows third party companies (such as money management apps) to authorise recurring payments from the customer's bank account to the merchants bank account.","title":"Variable Recurring Payments"},{"location":"open-banking-basics/","text":"Open Banking Basics How to make a domestic payment with Payment Initiation:","title":"Open Banking Basics"},{"location":"open-banking-basics/#open-banking-basics","text":"","title":"Open Banking Basics"},{"location":"open-banking-basics/#how-to-make-a-domestic-payment-with-payment-initiation","text":"","title":"How to make a domestic payment with Payment Initiation:"},{"location":"supported-open-banking-apis/","text":"Supported Open Banking APIs Open Banking Connector supports connections to banks using Open Banking APIs. This page details what APIs are supported. Generally the Open Banking Connector Fluent interface is based on the latest supported version of an API and older API versions are supported by request/response type mapping. For example, to send a DCR v3.1 request to a bank the request would first be mapped to a DCR v3.1 request and then the response mapped back to a v3.3 response. UK Open Banking Dynamic Client Registration API The UK Open Banking Dynamic Client Registration API is described here . Open Banking Connector supports the following versions of this API. API Version Type Mapping Comment v3.3 No type mapping is used Fluent interface based on this version v3.2 v3.3 request/repsonse types are mapped to v3.2 v3.1 v3.3 request/response types are mapped to v3.1 Open Banking Connector supports the following endpoints for this API. API Endpoint Fluent Interface Method POST /register requestBuilder.BankConfiguration.BankRegistrations.PostAsync() DELETE /register/{ClientId} requestBuilder.BankConfiguration.BankRegistrations.DeleteAsync() UK Open Banking Read-Write Payment Initation API The UK Open Banking Read-Write Payment Initiation API is described here . Open Banking Connector supports the following versions of this API. API Version Type Mapping Comment v3.1.6 No type mapping is used Fluent interface based on this version v3.1.4 v3.1.6 request/repsonse types are mapped to v3.1.4 [v3.1.2] Types present but mapping not yet implemented Open Banking Connector supports the following endpoints for this API. API Endpoint Fluent Interface Method POST \u200b/domestic-payment-consents requestBuilder .PaymentInitiation .DomesticPaymentConsents .PostAsync() GET \u200b/domestic-payment-consents/{ConsentId} requestBuilder .PaymentInitiation .DomesticPaymentConsents .GetAsync() GET \u200b/domestic-payment-consents/{ConsentId}/funds-confirmation requestBuilder .PaymentInitiation .DomesticPaymentConsents .GetFundsConfirmationAsync() POST \u200b/domestic-payments requestBuilder .PaymentInitiation .DomesticPayments .PostAsync() GET \u200b/domestic-payments\u200b/{DomesticPaymentId} requestBuilder .PaymentInitiation .DomesticPayments .GetAsync()","title":"Supported Open Banking API's"},{"location":"supported-open-banking-apis/#supported-open-banking-apis","text":"Open Banking Connector supports connections to banks using Open Banking APIs. This page details what APIs are supported. Generally the Open Banking Connector Fluent interface is based on the latest supported version of an API and older API versions are supported by request/response type mapping. For example, to send a DCR v3.1 request to a bank the request would first be mapped to a DCR v3.1 request and then the response mapped back to a v3.3 response.","title":"Supported Open Banking APIs"},{"location":"supported-open-banking-apis/#uk-open-banking-dynamic-client-registration-api","text":"The UK Open Banking Dynamic Client Registration API is described here . Open Banking Connector supports the following versions of this API. API Version Type Mapping Comment v3.3 No type mapping is used Fluent interface based on this version v3.2 v3.3 request/repsonse types are mapped to v3.2 v3.1 v3.3 request/response types are mapped to v3.1 Open Banking Connector supports the following endpoints for this API. API Endpoint Fluent Interface Method POST /register requestBuilder.BankConfiguration.BankRegistrations.PostAsync() DELETE /register/{ClientId} requestBuilder.BankConfiguration.BankRegistrations.DeleteAsync()","title":"UK Open Banking Dynamic Client Registration API"},{"location":"supported-open-banking-apis/#uk-open-banking-read-write-payment-initation-api","text":"The UK Open Banking Read-Write Payment Initiation API is described here . Open Banking Connector supports the following versions of this API. API Version Type Mapping Comment v3.1.6 No type mapping is used Fluent interface based on this version v3.1.4 v3.1.6 request/repsonse types are mapped to v3.1.4 [v3.1.2] Types present but mapping not yet implemented Open Banking Connector supports the following endpoints for this API. API Endpoint Fluent Interface Method POST \u200b/domestic-payment-consents requestBuilder .PaymentInitiation .DomesticPaymentConsents .PostAsync() GET \u200b/domestic-payment-consents/{ConsentId} requestBuilder .PaymentInitiation .DomesticPaymentConsents .GetAsync() GET \u200b/domestic-payment-consents/{ConsentId}/funds-confirmation requestBuilder .PaymentInitiation .DomesticPaymentConsents .GetFundsConfirmationAsync() POST \u200b/domestic-payments requestBuilder .PaymentInitiation .DomesticPayments .PostAsync() GET \u200b/domestic-payments\u200b/{DomesticPaymentId} requestBuilder .PaymentInitiation .DomesticPayments .GetAsync()","title":"UK Open Banking Read-Write Payment Initation API"},{"location":"architecture/","text":"OpenBanking.Library.Connector architecture Suggested API Components Classes Diagrams Diagrams have been created with draw.io free accounts and embedded as PNGs. The source files are *.drawio files.","title":"OpenBanking.Library.Connector architecture"},{"location":"architecture/#openbankinglibraryconnector-architecture","text":"Suggested API Components Classes","title":"OpenBanking.Library.Connector architecture"},{"location":"architecture/#diagrams","text":"Diagrams have been created with draw.io free accounts and embedded as PNGs. The source files are *.drawio files.","title":"Diagrams"},{"location":"architecture/Components/","text":"Components OpenBanking.Library.Connector OpenBanking.Library.Connector.IntegrationTests OpenBanking.Library.Connector.Benchmarks OpenBanking.Library.Service.Payments","title":"Components"},{"location":"architecture/Components/#components","text":"OpenBanking.Library.Connector OpenBanking.Library.Connector.IntegrationTests OpenBanking.Library.Connector.Benchmarks OpenBanking.Library.Service.Payments","title":"Components"},{"location":"architecture/OBC_Connector_Classes/","text":"Classes Interfaces IConfigurationProvider An interface for implementing runtime configuration. IClientProfileProvider An interface for implementing IInstrumentationClient An interface for implementing instrumentation concerns - tracing, logging, etc. Different platforms will have quite different requirements. IKeySecretProvider An interface for implementing a key secret provider. Implementations will implement platform concerns, e.g. Azure Key Vault. Fluent Interfaces/DSL TBD Models Public Model Canonical data entities for clients Model Transformations OB V1.x Auto-generated OpenBanking entities Networking ApiClient Base class for HTTP requests","title":"Classes"},{"location":"architecture/OBC_Connector_Classes/#classes","text":"","title":"Classes"},{"location":"architecture/OBC_Connector_Classes/#interfaces","text":"","title":"Interfaces"},{"location":"architecture/OBC_Connector_Classes/#iconfigurationprovider","text":"An interface for implementing runtime configuration.","title":"IConfigurationProvider"},{"location":"architecture/OBC_Connector_Classes/#iclientprofileprovider","text":"An interface for implementing","title":"IClientProfileProvider"},{"location":"architecture/OBC_Connector_Classes/#iinstrumentationclient","text":"An interface for implementing instrumentation concerns - tracing, logging, etc. Different platforms will have quite different requirements.","title":"IInstrumentationClient"},{"location":"architecture/OBC_Connector_Classes/#ikeysecretprovider","text":"An interface for implementing a key secret provider. Implementations will implement platform concerns, e.g. Azure Key Vault.","title":"IKeySecretProvider"},{"location":"architecture/OBC_Connector_Classes/#fluent-interfacesdsl","text":"TBD","title":"Fluent Interfaces/DSL"},{"location":"architecture/OBC_Connector_Classes/#models","text":"","title":"Models"},{"location":"architecture/OBC_Connector_Classes/#public-model","text":"Canonical data entities for clients","title":"Public Model"},{"location":"architecture/OBC_Connector_Classes/#model-transformations","text":"","title":"Model Transformations"},{"location":"architecture/OBC_Connector_Classes/#ob-v1x","text":"Auto-generated OpenBanking entities","title":"OB V1.x"},{"location":"architecture/OBC_Connector_Classes/#networking","text":"","title":"Networking"},{"location":"architecture/OBC_Connector_Classes/#apiclient","text":"Base class for HTTP requests","title":"ApiClient"},{"location":"architecture/OpenBanking.Connector.Benchmarks/","text":"OpenBanking.Library.Connector.Benchmarks Benchmarks is a standalone project intended to garner software performance benchmarks. It\u2019s intended to benchmark OpenBanking.Library.Connector code, and not the PISPs it integrates with. Its reports will help guide optimisation efforts and provide proof-of-quality to potential users. Implementation .Net Core 2.2 / C# 7 console application Incorporates BenchmarkDotNet (https://benchmarkdotnet.org/) Runtime profile Executed upon each build profiling with in-process mocks Executed upon integration test runs, for profiling against sandbox & live APIs Reports For selected in-process code pathways: Mean/StdDev/Min/Max/Median execution times Memory & garbage collection pressure .Net Core 2.2 & (.Net Core 3 in future) For selected sandbox APIs: Mean/StdDev/Min/Max/Median/Quartile execution times Memory & garbage collection pressure .Net Core 2.2 (.Net Core 3 in future)","title":"Benchmarks"},{"location":"architecture/OpenBanking.Connector.Benchmarks/#openbankinglibraryconnectorbenchmarks","text":"Benchmarks is a standalone project intended to garner software performance benchmarks. It\u2019s intended to benchmark OpenBanking.Library.Connector code, and not the PISPs it integrates with. Its reports will help guide optimisation efforts and provide proof-of-quality to potential users.","title":"OpenBanking.Library.Connector.Benchmarks"},{"location":"architecture/OpenBanking.Connector.Benchmarks/#implementation","text":".Net Core 2.2 / C# 7 console application Incorporates BenchmarkDotNet (https://benchmarkdotnet.org/)","title":"Implementation"},{"location":"architecture/OpenBanking.Connector.Benchmarks/#runtime-profile","text":"Executed upon each build profiling with in-process mocks Executed upon integration test runs, for profiling against sandbox & live APIs","title":"Runtime profile"},{"location":"architecture/OpenBanking.Connector.Benchmarks/#reports","text":"For selected in-process code pathways: Mean/StdDev/Min/Max/Median execution times Memory & garbage collection pressure .Net Core 2.2 & (.Net Core 3 in future) For selected sandbox APIs: Mean/StdDev/Min/Max/Median/Quartile execution times Memory & garbage collection pressure .Net Core 2.2 (.Net Core 3 in future)","title":"Reports"},{"location":"architecture/OpenBanking.Connector.IntegrationTests/","text":"OpenBanking.Library.Connector.IntegrationTests OpenBanking.Library.Connector.IntegrationTests is a single assembly containing all integration tests. These tests will cover: integration testing against our internal sandbox mock APIs integration testing against PISP partners' sandbox APIs QoS checks against PISP partner sandbox APIs & optionally live PISP APIs Dependencies: PISP sandbox mocks running getsandbox mocks PISP Partner sandboxes PISP partner sandboxes Runtime: Continual testing against our internal sandbox mock APIs - isolated tests On-demand execution against PISP Partner sandbox & live APIs Implementation: .NET Core 2 / C# 7 XUnit/BDD tests The tests' first facade is against the package\u2019s C# code and not HTTP endpoints. Specflow is rules out: it has licence requirements, and we want to make our source as widely usable as possible. Configuration: SSAs Certs Target API URLs Retained within the test project itself Namespaces Name Purpose LocalMockTests Tests against internal mocks PispTests Tests against PISP Sandboxes PispHealthTests Tests against PISP Sandbox & API to gauge health and discover API changes","title":"Integration Tests"},{"location":"architecture/OpenBanking.Connector.IntegrationTests/#openbankinglibraryconnectorintegrationtests","text":"OpenBanking.Library.Connector.IntegrationTests is a single assembly containing all integration tests. These tests will cover: integration testing against our internal sandbox mock APIs integration testing against PISP partners' sandbox APIs QoS checks against PISP partner sandbox APIs & optionally live PISP APIs","title":"OpenBanking.Library.Connector.IntegrationTests"},{"location":"architecture/OpenBanking.Connector.IntegrationTests/#dependencies","text":"PISP sandbox mocks running getsandbox mocks PISP Partner sandboxes PISP partner sandboxes","title":"Dependencies:"},{"location":"architecture/OpenBanking.Connector.IntegrationTests/#runtime","text":"Continual testing against our internal sandbox mock APIs - isolated tests On-demand execution against PISP Partner sandbox & live APIs","title":"Runtime:"},{"location":"architecture/OpenBanking.Connector.IntegrationTests/#implementation","text":".NET Core 2 / C# 7 XUnit/BDD tests The tests' first facade is against the package\u2019s C# code and not HTTP endpoints. Specflow is rules out: it has licence requirements, and we want to make our source as widely usable as possible.","title":"Implementation:"},{"location":"architecture/OpenBanking.Connector.IntegrationTests/#configuration","text":"SSAs Certs Target API URLs Retained within the test project itself","title":"Configuration:"},{"location":"architecture/OpenBanking.Connector.IntegrationTests/#namespaces","text":"Name Purpose LocalMockTests Tests against internal mocks PispTests Tests against PISP Sandboxes PispHealthTests Tests against PISP Sandbox & API to gauge health and discover API changes","title":"Namespaces"},{"location":"architecture/OpenBanking.Connector/","text":"OpenBanking.Library.Connector.Payments OpenBanking.Library.Connector.Payments is the main deliverable assembly for OBC.NET. Features: .Net Standard library for direct integration into .Net Core/Xamarin applications and services Heterogenous Bank PISP APIs are abstracted to a canonical model Fluent, domain-driven client interface Interface abstractions for external services (DB, key store, instrumentation, etc) Dependency injection following ASP.NET Core DI patterns Implementation: .NET Standard 2 C# 7 We intend to upgrade to C# 8 in the near future. Namespaces: The main package's root namespace is FinnovationLabs.OpenBanking.Library.Connector . Namespace Purpose .Configuration Run-time configuration .Http HTTP utilities .Instrumentation Instrumentation abstractions .Json JSON utilities .Model Entity declarations. These describe the structure of messages, not their behaviour. .Model.Public All client-facing entity types. These are canonical models that will cover versions .Model.Payments Internal, auto-generated entity code. These are all sourced from OpenBanking PISP model OpenAPIs .Model.Payments.V3_1_0 OpenBanking OpenAPI v3.1.0 .Model.Payments.V3_1_1 OpenBanking OpenAPI v3.1.1 .Model.Payments.V3_1_2 OpenBanking OpenAPI v3.1.2 .Payments Payments behaviour implementation .Security JWT/JWS utilities Usage See here","title":"OpenBanking.Library.Connector.Payments"},{"location":"architecture/OpenBanking.Connector/#openbankinglibraryconnectorpayments","text":"OpenBanking.Library.Connector.Payments is the main deliverable assembly for OBC.NET.","title":"OpenBanking.Library.Connector.Payments"},{"location":"architecture/OpenBanking.Connector/#features","text":".Net Standard library for direct integration into .Net Core/Xamarin applications and services Heterogenous Bank PISP APIs are abstracted to a canonical model Fluent, domain-driven client interface Interface abstractions for external services (DB, key store, instrumentation, etc) Dependency injection following ASP.NET Core DI patterns","title":"Features:"},{"location":"architecture/OpenBanking.Connector/#implementation","text":".NET Standard 2 C# 7 We intend to upgrade to C# 8 in the near future.","title":"Implementation:"},{"location":"architecture/OpenBanking.Connector/#namespaces","text":"The main package's root namespace is FinnovationLabs.OpenBanking.Library.Connector . Namespace Purpose .Configuration Run-time configuration .Http HTTP utilities .Instrumentation Instrumentation abstractions .Json JSON utilities .Model Entity declarations. These describe the structure of messages, not their behaviour. .Model.Public All client-facing entity types. These are canonical models that will cover versions .Model.Payments Internal, auto-generated entity code. These are all sourced from OpenBanking PISP model OpenAPIs .Model.Payments.V3_1_0 OpenBanking OpenAPI v3.1.0 .Model.Payments.V3_1_1 OpenBanking OpenAPI v3.1.1 .Model.Payments.V3_1_2 OpenBanking OpenAPI v3.1.2 .Payments Payments behaviour implementation .Security JWT/JWS utilities","title":"Namespaces:"},{"location":"architecture/OpenBanking.Connector/#usage","text":"See here","title":"Usage"},{"location":"architecture/OpenBanking.Service.Payments/","text":"OpenBanking.Service.Payments A sample Azure Function project demonstrating OpenBankingConnector.Net. It is intended to guide users in the library's use on a local development machine. As such it is a simplified form and not intended to be production ready. Runtime Azure Function v2 .Net core 2 (Core 3 once full support is applied) C# 7 Endpoints See here Dependencies Type Dependency Notes Database Cosmos DB CosmosDB is the defacto elastic high availability database in Azure. Instrumentation Azure Application Insights App Insights is the standard application instrumentation platform within Azure. Keystore Azure Key Vault Standard key storage platform within Azure.","title":"Service Payments"},{"location":"architecture/OpenBanking.Service.Payments/#openbankingservicepayments","text":"A sample Azure Function project demonstrating OpenBankingConnector.Net. It is intended to guide users in the library's use on a local development machine. As such it is a simplified form and not intended to be production ready.","title":"OpenBanking.Service.Payments"},{"location":"architecture/OpenBanking.Service.Payments/#runtime","text":"Azure Function v2 .Net core 2 (Core 3 once full support is applied) C# 7","title":"Runtime"},{"location":"architecture/OpenBanking.Service.Payments/#endpoints","text":"See here","title":"Endpoints"},{"location":"architecture/OpenBanking.Service.Payments/#dependencies","text":"Type Dependency Notes Database Cosmos DB CosmosDB is the defacto elastic high availability database in Azure. Instrumentation Azure Application Insights App Insights is the standard application instrumentation platform within Azure. Keystore Azure Key Vault Standard key storage platform within Azure.","title":"Dependencies"},{"location":"architecture/Suggested_API_endpoints/","text":"API Endpoints These are the suggested HTTP API endpoints for sample services. These will help drive implementations for sample & test services by showing the extent of future client-API interactions. Please note that our intention is to provide a library and not to provide a production-quality service: the service will use the library. Area Name Method Path Request Response General Create Software Statement Profiles POST /software-statement-profiles SoftwareStatementProfile SoftwareStatementProfile Create OB Client PRofile POST /register OBClientProfile OBClientProfile PISP API Create Domestic Payment Consents POST /pisp/domestic-payment-constents OBWriteDomesticConentPublic OBWriteDomesticConsentResponsePublic Get Domestic Payment Consents GET /pisp/domestic-payment-consents/{consentId} OBWriteDomesticConsentResponsePublic Get Domestic Payment Consents (FC) GET /pisp/domestic-payment-consents/{consentId}/funds-confirmation OBWriteFundsConfirmationResponsePublic Create Domestic Payments POST /pisp/domestic-payments OBWriteDomesticPublic OBWriteDomesticResponsePublic Get Domestic Payments GET /pisp/domestic-payments/{domesticPaymentId} OBWriteDomesticConstentResponsePublic \"Public\" types will eventually be denoted by their namespace. An API would not expose a type with that suffix. FC: Funds Confirmation","title":"Suggested API endpoints"},{"location":"architecture/Suggested_API_endpoints/#api-endpoints","text":"These are the suggested HTTP API endpoints for sample services. These will help drive implementations for sample & test services by showing the extent of future client-API interactions. Please note that our intention is to provide a library and not to provide a production-quality service: the service will use the library. Area Name Method Path Request Response General Create Software Statement Profiles POST /software-statement-profiles SoftwareStatementProfile SoftwareStatementProfile Create OB Client PRofile POST /register OBClientProfile OBClientProfile PISP API Create Domestic Payment Consents POST /pisp/domestic-payment-constents OBWriteDomesticConentPublic OBWriteDomesticConsentResponsePublic Get Domestic Payment Consents GET /pisp/domestic-payment-consents/{consentId} OBWriteDomesticConsentResponsePublic Get Domestic Payment Consents (FC) GET /pisp/domestic-payment-consents/{consentId}/funds-confirmation OBWriteFundsConfirmationResponsePublic Create Domestic Payments POST /pisp/domestic-payments OBWriteDomesticPublic OBWriteDomesticResponsePublic Get Domestic Payments GET /pisp/domestic-payments/{domesticPaymentId} OBWriteDomesticConstentResponsePublic \"Public\" types will eventually be denoted by their namespace. An API would not expose a type with that suffix. FC: Funds Confirmation","title":"API Endpoints"},{"location":"configuration/","text":"Configuration Configuration for the Open Banking Connetor web app is read-only information that customises the behaviour of the app. This is in contrast to database access which is read-write. This page describes configuration used by the app and how to provide it. Configuration is normally provided by either a key secret vault (including the local Microsoft secret manager ) and/or environment variables. Structure The Open Banking connector web app makes available a number of settings to support app configuration. Configuration then consists of a set of key-value pairs which give values to available settings . Settings (and hence keys) have a hierarchical naming structure where the first \"level\" is always OpenBankingConnector and subsequent levels are separated by colons (:). Values are always representable as strings (although in JSON files, where applicable and optionally, they may be represented in natural form as numbers and booleans). Here is an example of a key-value pair that configures the Open Bnaking Connector database provider to be \"Sqlite\" : Key (Setting Name) Value OpenBankingConnector:Database:Provider \"Sqlite\" Sources The app as a baseline uses the ASP.NET Core Default Configuration to collect configuration from a number of configuration sources in priority order. In practice, this means default values for settings are provided by code defaults (see ISettings classes) and the two appsettings.json files for the app ( appsettings.json and appsettings.Development.json ) included in the public repo. Customisation (user configuration) is then provided either by a key secret vault and/or environment variables. When building and running the web app from source code (rather than using a container) in the development environment , the local Microsoft secret manager may be used in place of a cloud-based key secret vault. Important : Some settings values are very sensitive, for example keys, and should be very carefully and securely stored and managed. These should never be stored in-repo, for example in additional or modified appsettings.json files, due to the risk of disclosure. The Microsoft secret manager allows sensitive secrets to be stored far removed from the local repo during code development and testing. Environment selection The Open Banking Connector web app allows use of different environments such as development, staging and production. In practice, app behaviour is only actually sensitive to whether it is run in the development environment. Other environments can be used as desired by the user but they should not affect app behaviour. In the development environment, logging, error handling and configuration defaults etc are modified to suit the needs of developing and testing the app. The development environment should not be used in production. Environment selection is not configured by Open Banking Connector web app settings but normally via the Microsoft DOTNET_ENVIRONMENT or ASPNETCORE_ENVIRONMENT environment variables. Please see below for an example of how to set environemnt variables when running the app. The default environment is production (not development) in most situations including when running the web app container (see here for more details). Settings groups Open Banking Connector web app configuration settings are collected into groups which are described in their own pages: database settings which configure the database used by the app software statement profiles settings which configure software statement profiles used by the app transport certificate profiles settings which configure transport certificate profiles used by the app signing certificate profiles settings which configure signing certificate profiles used by the app Minimal required configuration In the development environment , at least the following should be configured to allow a bank registration to be performed: a software statement profile with an associated transport certificate profile and signing certificate profile . When not in the development environment, additionally at least the following should be configured to allow a bank registration to be performed: a database provider and connection string Provide configuration We here provide some guidance and examples of how to provide configuration to the Open Banking Connector web app from various sources. Using the Microsoft secret manager To use the Microsoft secret manager, you will need a secrets.json file in the appropriate directory (if you do not have one already). The Microsoft documentation here gives the path for this directory. Please note that the UserSecretsId for the app is aa921213-9461-4f9e-8fec-153624ec67ad as given here . You can then add key-value pairs to the secrets.json file to supply settings to the app. Here is an example of what such a file might look like after configuring a software statement profile, transport certificate profile and signing certificate profile: { \"OpenBankingConnector:TransportCertificateProfiles:New2:CertificateDnWithStringDottedDecimalAttributeValues\" : \"CN=abc,2.5.4.97=abc,O=abc,C=GB\" , \"OpenBankingConnector:TransportCertificateProfiles:New2:CertificateDnWithHexDottedDecimalAttributeValues\" : \"CN=abc,2.5.4.97=#123,O=abc,C=GB\" , \"OpenBankingConnector:TransportCertificateProfiles:New2:Certificate\" : \"-----BEGIN CERTIFICATE-----\\nabc\\n-----END CERTIFICATE-----\\n\" , \"OpenBankingConnector:TransportCertificateProfiles:New2:AssociatedKey\" : \"-----BEGIN PRIVATE KEY-----\\nabc\\n-----END PRIVATE KEY-----\\n\" , \"OpenBankingConnector:SoftwareStatementProfiles:All:TransportCertificateProfileId\" : \"New2\" , \"OpenBankingConnector:SoftwareStatementProfiles:All:SoftwareStatement\" : \"a.b.c\" , \"OpenBankingConnector:SoftwareStatementProfiles:All:SigningCertificateProfileId\" : \"New2\" , \"OpenBankingConnector:SoftwareStatementProfiles:All:DefaultFragmentRedirectUrl\" : \"https://example.com/auth/fragment-redirect\" , \"OpenBankingConnector:SigningCertificateProfiles:New2:Certificate\" : \"-----BEGIN CERTIFICATE-----\\nabc\\n-----END CERTIFICATE-----\\n\" , \"OpenBankingConnector:SigningCertificateProfiles:New2:AssociatedKeyId\" : \"abc\" , \"OpenBankingConnector:SigningCertificateProfiles:New2:AssociatedKey\" : \"-----BEGIN PRIVATE KEY-----\\nabc\\n-----END PRIVATE KEY-----\\n\" } Using Environment Variables When providing settings via environment variables, it is recommended to use double underscores (__) in place of colons (:) in the keys. So, for instance, the key OpenBankingConnector:Database:Provider would become OpenBankingConnector__Database__Provider. The reasoning for this is provided here . Here is an example of how to run the web app container using envirnoment variables to (a) use the development environment and (b) set the DB provider to \"Sqlite\" : docker run -dt -e \"DOTNET_ENVIRONMENT=Development\" -e \"OpenBankingConnector__Database__Provider=Sqlite\" -P - -name OpenBanking . WebApp . Connector . v1 . 0 . 0-alpha03 ghcr . io / finlabsuk / open-banking -connector-web-app : 1 . 0 . 0-alpha03","title":"Configuration"},{"location":"configuration/#configuration","text":"Configuration for the Open Banking Connetor web app is read-only information that customises the behaviour of the app. This is in contrast to database access which is read-write. This page describes configuration used by the app and how to provide it. Configuration is normally provided by either a key secret vault (including the local Microsoft secret manager ) and/or environment variables.","title":"Configuration"},{"location":"configuration/#structure","text":"The Open Banking connector web app makes available a number of settings to support app configuration. Configuration then consists of a set of key-value pairs which give values to available settings . Settings (and hence keys) have a hierarchical naming structure where the first \"level\" is always OpenBankingConnector and subsequent levels are separated by colons (:). Values are always representable as strings (although in JSON files, where applicable and optionally, they may be represented in natural form as numbers and booleans). Here is an example of a key-value pair that configures the Open Bnaking Connector database provider to be \"Sqlite\" : Key (Setting Name) Value OpenBankingConnector:Database:Provider \"Sqlite\"","title":"Structure"},{"location":"configuration/#sources","text":"The app as a baseline uses the ASP.NET Core Default Configuration to collect configuration from a number of configuration sources in priority order. In practice, this means default values for settings are provided by code defaults (see ISettings classes) and the two appsettings.json files for the app ( appsettings.json and appsettings.Development.json ) included in the public repo. Customisation (user configuration) is then provided either by a key secret vault and/or environment variables. When building and running the web app from source code (rather than using a container) in the development environment , the local Microsoft secret manager may be used in place of a cloud-based key secret vault. Important : Some settings values are very sensitive, for example keys, and should be very carefully and securely stored and managed. These should never be stored in-repo, for example in additional or modified appsettings.json files, due to the risk of disclosure. The Microsoft secret manager allows sensitive secrets to be stored far removed from the local repo during code development and testing.","title":"Sources"},{"location":"configuration/#environment-selection","text":"The Open Banking Connector web app allows use of different environments such as development, staging and production. In practice, app behaviour is only actually sensitive to whether it is run in the development environment. Other environments can be used as desired by the user but they should not affect app behaviour. In the development environment, logging, error handling and configuration defaults etc are modified to suit the needs of developing and testing the app. The development environment should not be used in production. Environment selection is not configured by Open Banking Connector web app settings but normally via the Microsoft DOTNET_ENVIRONMENT or ASPNETCORE_ENVIRONMENT environment variables. Please see below for an example of how to set environemnt variables when running the app. The default environment is production (not development) in most situations including when running the web app container (see here for more details).","title":"Environment selection"},{"location":"configuration/#settings-groups","text":"Open Banking Connector web app configuration settings are collected into groups which are described in their own pages: database settings which configure the database used by the app software statement profiles settings which configure software statement profiles used by the app transport certificate profiles settings which configure transport certificate profiles used by the app signing certificate profiles settings which configure signing certificate profiles used by the app","title":"Settings groups"},{"location":"configuration/#minimal-required-configuration","text":"In the development environment , at least the following should be configured to allow a bank registration to be performed: a software statement profile with an associated transport certificate profile and signing certificate profile . When not in the development environment, additionally at least the following should be configured to allow a bank registration to be performed: a database provider and connection string","title":"Minimal required configuration"},{"location":"configuration/#provide-configuration","text":"We here provide some guidance and examples of how to provide configuration to the Open Banking Connector web app from various sources.","title":"Provide configuration"},{"location":"configuration/#using-the-microsoft-secret-manager","text":"To use the Microsoft secret manager, you will need a secrets.json file in the appropriate directory (if you do not have one already). The Microsoft documentation here gives the path for this directory. Please note that the UserSecretsId for the app is aa921213-9461-4f9e-8fec-153624ec67ad as given here . You can then add key-value pairs to the secrets.json file to supply settings to the app. Here is an example of what such a file might look like after configuring a software statement profile, transport certificate profile and signing certificate profile: { \"OpenBankingConnector:TransportCertificateProfiles:New2:CertificateDnWithStringDottedDecimalAttributeValues\" : \"CN=abc,2.5.4.97=abc,O=abc,C=GB\" , \"OpenBankingConnector:TransportCertificateProfiles:New2:CertificateDnWithHexDottedDecimalAttributeValues\" : \"CN=abc,2.5.4.97=#123,O=abc,C=GB\" , \"OpenBankingConnector:TransportCertificateProfiles:New2:Certificate\" : \"-----BEGIN CERTIFICATE-----\\nabc\\n-----END CERTIFICATE-----\\n\" , \"OpenBankingConnector:TransportCertificateProfiles:New2:AssociatedKey\" : \"-----BEGIN PRIVATE KEY-----\\nabc\\n-----END PRIVATE KEY-----\\n\" , \"OpenBankingConnector:SoftwareStatementProfiles:All:TransportCertificateProfileId\" : \"New2\" , \"OpenBankingConnector:SoftwareStatementProfiles:All:SoftwareStatement\" : \"a.b.c\" , \"OpenBankingConnector:SoftwareStatementProfiles:All:SigningCertificateProfileId\" : \"New2\" , \"OpenBankingConnector:SoftwareStatementProfiles:All:DefaultFragmentRedirectUrl\" : \"https://example.com/auth/fragment-redirect\" , \"OpenBankingConnector:SigningCertificateProfiles:New2:Certificate\" : \"-----BEGIN CERTIFICATE-----\\nabc\\n-----END CERTIFICATE-----\\n\" , \"OpenBankingConnector:SigningCertificateProfiles:New2:AssociatedKeyId\" : \"abc\" , \"OpenBankingConnector:SigningCertificateProfiles:New2:AssociatedKey\" : \"-----BEGIN PRIVATE KEY-----\\nabc\\n-----END PRIVATE KEY-----\\n\" }","title":"Using the Microsoft secret manager"},{"location":"configuration/#using-environment-variables","text":"When providing settings via environment variables, it is recommended to use double underscores (__) in place of colons (:) in the keys. So, for instance, the key OpenBankingConnector:Database:Provider would become OpenBankingConnector__Database__Provider. The reasoning for this is provided here . Here is an example of how to run the web app container using envirnoment variables to (a) use the development environment and (b) set the DB provider to \"Sqlite\" : docker run -dt -e \"DOTNET_ENVIRONMENT=Development\" -e \"OpenBankingConnector__Database__Provider=Sqlite\" -P - -name OpenBanking . WebApp . Connector . v1 . 0 . 0-alpha03 ghcr . io / finlabsuk / open-banking -connector-web-app : 1 . 0 . 0-alpha03","title":"Using Environment Variables"},{"location":"configuration/database-settings/","text":"Database settings Database settings are used to configure the database used by Open Banking Connector to read and write data. In the development environment , default settings are provided in appsettings.Development.json to allow auto-creation and use of a local SQLite file as the databse. In non-development envrionments, you will at least need to at least provide a connection string setting for the configured database provider. Database settings are defined in the DatabaseSettings class. Settings Name Valid Values Default Value(s) Description OpenBankingConnector :Database :Provider { \"Sqlite\" , \"Postgres\" } \"Sqlite\" Determines which database provider Open Banking Connector uses. OpenBankingConnector :Database :ConnectionStrings:{Provider} where Provider \u2208 {Sqlite, Postgres} string \"Data Source=./sqliteTestDb.db\" (development environment and Provider = \"Sqlite\" ) - (otherwise) Connection strings for each database provider. Open Banking Connector only reads the one for the provider specified by OpenBankingConnector:Database:Provider. The BankTests project, however, may use multiple connection strings to test with multiple databases. OpenBankingConnector :Database :EnsureDbCreated { \"true\" , \"false\" } \"true\" (development environment) \"false\" (otherwise) Ensures database is created if does not exist. Intended for use in Development environment only.","title":"Database settings"},{"location":"configuration/database-settings/#database-settings","text":"Database settings are used to configure the database used by Open Banking Connector to read and write data. In the development environment , default settings are provided in appsettings.Development.json to allow auto-creation and use of a local SQLite file as the databse. In non-development envrionments, you will at least need to at least provide a connection string setting for the configured database provider. Database settings are defined in the DatabaseSettings class.","title":"Database settings"},{"location":"configuration/database-settings/#settings","text":"Name Valid Values Default Value(s) Description OpenBankingConnector :Database :Provider { \"Sqlite\" , \"Postgres\" } \"Sqlite\" Determines which database provider Open Banking Connector uses. OpenBankingConnector :Database :ConnectionStrings:{Provider} where Provider \u2208 {Sqlite, Postgres} string \"Data Source=./sqliteTestDb.db\" (development environment and Provider = \"Sqlite\" ) - (otherwise) Connection strings for each database provider. Open Banking Connector only reads the one for the provider specified by OpenBankingConnector:Database:Provider. The BankTests project, however, may use multiple connection strings to test with multiple databases. OpenBankingConnector :Database :EnsureDbCreated { \"true\" , \"false\" } \"true\" (development environment) \"false\" (otherwise) Ensures database is created if does not exist. Intended for use in Development environment only.","title":"Settings"},{"location":"configuration/signing-certificate-profiles-settings/","text":"Signing certificate profiles settings Signing certificate profiles settings are used to configure signing certificate profiles used by Open Banking Connector. A signing certificate profile is a set of settings comprising a signing key and certificate pair and related information. It is identified by a user-defined profile ID. It is referenced by one or more software statement profiles . A signing key-certificate pair is used for signing JWTs that are sent to banks. No signing certificate profiles are configured by default and you will require at least one in order to create a bank registration. Signing certificate profiles settings are defined in the SigningCertificateProfilesSettings class. Settings Name Valid Values Default Value(s) Description OpenBankingConnector :SigningCertificateProfiles :{Id} :Active where string Id is user-defined profile ID { \"true\" , \"false\" } \"true\" Whether profile is active or inactive (ignored by Open Banking Connector). This allows profiles to be \"switched on and off\" for testing etc. OpenBankingConnector :SigningCertificateProfiles :{Id} :SigningCertificateType where string Id is user-defined profile ID { \"OBLegacy\" , \"OBSeal\" } \"OBSeal\" Type of UK Open Banking Directory certificate used. OpenBankingConnector :SigningCertificateProfiles :{Id} :AssociatedKeyId where string Id is user-defined profile ID string - Signing Key ID (from UK Open Banking Directory) as string. This is not the same as the user-definied profile ID for this profile. OpenBankingConnector :SigningCertificateProfiles :{Id} :AssociatedKey where string Id is user-defined profile ID string - Signing key (PKCS #8) as \"stringified\" PEM file with escaped newline characters (\" \\n \") and PRIVATE KEY label. Example: \"-----BEGIN PRIVATE KEY-----\\nABC\\n-----END PRIVATE KEY-----\\n\" . OpenBankingConnector :SigningCertificateProfiles :{Id} :Certificate where string Id is user-defined profile ID string - Signing certificate (X.509) as \"stringified\" PEM file with escaped newline characters ( \"\\n\" ) and CERTIFICATE label. Example: \"-----BEGIN CERTIFICATE-----\\nABC\\n-----END CERTIFICATE-----\\n\" .","title":"Signing certificate profiles settings"},{"location":"configuration/signing-certificate-profiles-settings/#signing-certificate-profiles-settings","text":"Signing certificate profiles settings are used to configure signing certificate profiles used by Open Banking Connector. A signing certificate profile is a set of settings comprising a signing key and certificate pair and related information. It is identified by a user-defined profile ID. It is referenced by one or more software statement profiles . A signing key-certificate pair is used for signing JWTs that are sent to banks. No signing certificate profiles are configured by default and you will require at least one in order to create a bank registration. Signing certificate profiles settings are defined in the SigningCertificateProfilesSettings class.","title":"Signing certificate profiles settings"},{"location":"configuration/signing-certificate-profiles-settings/#settings","text":"Name Valid Values Default Value(s) Description OpenBankingConnector :SigningCertificateProfiles :{Id} :Active where string Id is user-defined profile ID { \"true\" , \"false\" } \"true\" Whether profile is active or inactive (ignored by Open Banking Connector). This allows profiles to be \"switched on and off\" for testing etc. OpenBankingConnector :SigningCertificateProfiles :{Id} :SigningCertificateType where string Id is user-defined profile ID { \"OBLegacy\" , \"OBSeal\" } \"OBSeal\" Type of UK Open Banking Directory certificate used. OpenBankingConnector :SigningCertificateProfiles :{Id} :AssociatedKeyId where string Id is user-defined profile ID string - Signing Key ID (from UK Open Banking Directory) as string. This is not the same as the user-definied profile ID for this profile. OpenBankingConnector :SigningCertificateProfiles :{Id} :AssociatedKey where string Id is user-defined profile ID string - Signing key (PKCS #8) as \"stringified\" PEM file with escaped newline characters (\" \\n \") and PRIVATE KEY label. Example: \"-----BEGIN PRIVATE KEY-----\\nABC\\n-----END PRIVATE KEY-----\\n\" . OpenBankingConnector :SigningCertificateProfiles :{Id} :Certificate where string Id is user-defined profile ID string - Signing certificate (X.509) as \"stringified\" PEM file with escaped newline characters ( \"\\n\" ) and CERTIFICATE label. Example: \"-----BEGIN CERTIFICATE-----\\nABC\\n-----END CERTIFICATE-----\\n\" .","title":"Settings"},{"location":"configuration/software-statement-profiles-settings/","text":"Software statement profiles settings Software statement profiles settings are used to configure software statement profiles used by Open Banking Connector. A software statement profile is a set of settings comprising a software statement assertion (SSA) and information related to that SSA. It is identified by a user-defined profile ID. It references an associated transport certificiate profile and an associated signing certificate profile . All three profiles may be created after e.g. getting a software statement assertion (SSA) and signed certificates using the UK Open Banking Directory . No software statement profiles are configured by default and you will require at least one in order to create a bank registration. Software statement profiles settings are defined in the SoftwareStatementProfilesSettings class. Settings Name Valid Values Default Value(s) Description OpenBankingConnector :SoftwareStatementProfiles :{Id} :Active where string Id is user-defined profile ID { \"true\" , \"false\" } \"true\" Whether profile is active or inactive (ignored by Open Banking Connector). This allows profiles to be \"switched on and off\" for testing etc. OpenBankingConnector :SoftwareStatementProfiles :{Id} :SoftwareStatement where string Id is user-defined profile ID string - Software statement assertion (SSA) as string, i.e. \"FirstPart.SecondPart.ThirdPart\". OpenBankingConnector :SoftwareStatementProfiles :{Id} :TransportCertificateProfileId where string Id is user-defined profile ID string - ID of transport certificiate profile to use for mutual TLS with this software statement profile. OpenBankingConnector :SoftwareStatementProfiles :{Id} :SigningCertificateProfileId where string Id is user-defined profile ID string - ID of signing certificiate profile to use for signing JWTs etc with this software statement profile. OpenBankingConnector :SoftwareStatementProfiles :{Id} :DefaultFragmentRedirectUrl where string Id is user-defined profile ID string - Default redirect URL for consent authorisations when OAuth2 response_mode = fragment .","title":"Software statement profiles settings"},{"location":"configuration/software-statement-profiles-settings/#software-statement-profiles-settings","text":"Software statement profiles settings are used to configure software statement profiles used by Open Banking Connector. A software statement profile is a set of settings comprising a software statement assertion (SSA) and information related to that SSA. It is identified by a user-defined profile ID. It references an associated transport certificiate profile and an associated signing certificate profile . All three profiles may be created after e.g. getting a software statement assertion (SSA) and signed certificates using the UK Open Banking Directory . No software statement profiles are configured by default and you will require at least one in order to create a bank registration. Software statement profiles settings are defined in the SoftwareStatementProfilesSettings class.","title":"Software statement profiles settings"},{"location":"configuration/software-statement-profiles-settings/#settings","text":"Name Valid Values Default Value(s) Description OpenBankingConnector :SoftwareStatementProfiles :{Id} :Active where string Id is user-defined profile ID { \"true\" , \"false\" } \"true\" Whether profile is active or inactive (ignored by Open Banking Connector). This allows profiles to be \"switched on and off\" for testing etc. OpenBankingConnector :SoftwareStatementProfiles :{Id} :SoftwareStatement where string Id is user-defined profile ID string - Software statement assertion (SSA) as string, i.e. \"FirstPart.SecondPart.ThirdPart\". OpenBankingConnector :SoftwareStatementProfiles :{Id} :TransportCertificateProfileId where string Id is user-defined profile ID string - ID of transport certificiate profile to use for mutual TLS with this software statement profile. OpenBankingConnector :SoftwareStatementProfiles :{Id} :SigningCertificateProfileId where string Id is user-defined profile ID string - ID of signing certificiate profile to use for signing JWTs etc with this software statement profile. OpenBankingConnector :SoftwareStatementProfiles :{Id} :DefaultFragmentRedirectUrl where string Id is user-defined profile ID string - Default redirect URL for consent authorisations when OAuth2 response_mode = fragment .","title":"Settings"},{"location":"configuration/transport-certificate-profiles-settings/","text":"Transport certificate profiles settings Transport certificate profiles settings are used to configure transport certificate profiles used by Open Banking Connector. A transport certificate profile is a set of settings comprising a transport key and certificate pair and related information. It is identified by a user-defined profile ID. It is referenced by one or more software statement profiles . A transport key-certificate pair is used for mutual TLS when commuinicating with banks. No transport certificate profiles are configured by default and you will require at least one in order to create a bank registration. Transport certificate profiles settings are defined in the TransportCertificateProfilesSettings class. Settings Name Valid Values Default Value(s) Description OpenBankingConnector :TransportCertificateProfiles :{Id} :Active where string Id is user-defined profile ID { \"true\" , \"false\" } \"true\" Whether profile is active or inactive (ignored by Open Banking Connector). This allows profiles to be \"switched on and off\" for testing etc. OpenBankingConnector :TransportCertificateProfiles :{Id} :TransportCertificateType where string Id is user-defined profile ID { \"OBLegacy\" , \"OBWac\" } \"OBWac\" Type of UK Open Banking Directory certificate used. OpenBankingConnector :TransportCertificateProfiles :{Id} :DisableTlsCertificateVerification where string Id is user-defined profile ID { \"true\" , \"false\" } \"false\" Disable verification of external bank TLS certificates when using mutual TLS with this certificate profile. Not intended for production use but sometimes helpful for diagnosing issues with bank sandboxes (e.g. if they use self-signed certificates). OpenBankingConnector :TransportCertificateProfiles :{Id} :CertificateDnWithHexDottedDecimalAttributeValues where string Id is user-defined profile ID string - Transport certificate DN to use for bank registration (DCR) with hex values for dotted-decimal attributes (as specified by https://datatracker.ietf.org/doc/html/rfc4514#section-2.4 ). Whether CertificateDnWithHexDottedDecimalAttributeValues setting or CertificateDnWithStringDottedDecimalAttributeValues setting is used in bank registration is determined by bank registration request property UseTransportCertificateDnWithStringNotHexDottedDecimalAttributeValues. . This setting is ignored when TransportCertificateType = \"OBLegacy\" . OpenBankingConnector :TransportCertificateProfiles :{Id} :CertificateDnWithStringDottedDecimalAttributeValues where string Id is user-defined profile ID string - Alternative transport certificate DN to use for bank registration (DCR) with string (not hex) values for dotted-decimal attributes (required by some banks). Whether ertificateDnWithHexDottedDecimalAttributeValues setting or CertificateDnWithStringDottedDecimalAttributeValues setting is used in bank registration is determined by bank registration request property UseTransportCertificateDnWithStringNotHexDottedDecimalAttributeValues. This setting is ignored when TransportCertificateType = \"OBLegacy\" . OpenBankingConnector :TransportCertificateProfiles :{Id} :AssociatedKey where string Id is user-defined profile ID string - Transport key (PKCS #8) as \"stringified\" PEM file with escaped newline characters ( \"\\n\" ) and PRIVATE KEY label. Example: \"-----BEGIN PRIVATE KEY-----\\nABC\\n-----END PRIVATE KEY-----\\n\" . OpenBankingConnector :TransportCertificateProfiles :{Id} :Certificate where string Id is user-defined profile ID string - Transport certificate (X.509) as \"stringified\" PEM file with escaped newline characters ( \"\\n\" ) and CERTIFICATE label. Example: \"-----BEGIN CERTIFICATE-----\\nABC\\n-----END CERTIFICATE-----\\n\" .","title":"Transport certificate profiles settings"},{"location":"configuration/transport-certificate-profiles-settings/#transport-certificate-profiles-settings","text":"Transport certificate profiles settings are used to configure transport certificate profiles used by Open Banking Connector. A transport certificate profile is a set of settings comprising a transport key and certificate pair and related information. It is identified by a user-defined profile ID. It is referenced by one or more software statement profiles . A transport key-certificate pair is used for mutual TLS when commuinicating with banks. No transport certificate profiles are configured by default and you will require at least one in order to create a bank registration. Transport certificate profiles settings are defined in the TransportCertificateProfilesSettings class.","title":"Transport certificate profiles settings"},{"location":"configuration/transport-certificate-profiles-settings/#settings","text":"Name Valid Values Default Value(s) Description OpenBankingConnector :TransportCertificateProfiles :{Id} :Active where string Id is user-defined profile ID { \"true\" , \"false\" } \"true\" Whether profile is active or inactive (ignored by Open Banking Connector). This allows profiles to be \"switched on and off\" for testing etc. OpenBankingConnector :TransportCertificateProfiles :{Id} :TransportCertificateType where string Id is user-defined profile ID { \"OBLegacy\" , \"OBWac\" } \"OBWac\" Type of UK Open Banking Directory certificate used. OpenBankingConnector :TransportCertificateProfiles :{Id} :DisableTlsCertificateVerification where string Id is user-defined profile ID { \"true\" , \"false\" } \"false\" Disable verification of external bank TLS certificates when using mutual TLS with this certificate profile. Not intended for production use but sometimes helpful for diagnosing issues with bank sandboxes (e.g. if they use self-signed certificates). OpenBankingConnector :TransportCertificateProfiles :{Id} :CertificateDnWithHexDottedDecimalAttributeValues where string Id is user-defined profile ID string - Transport certificate DN to use for bank registration (DCR) with hex values for dotted-decimal attributes (as specified by https://datatracker.ietf.org/doc/html/rfc4514#section-2.4 ). Whether CertificateDnWithHexDottedDecimalAttributeValues setting or CertificateDnWithStringDottedDecimalAttributeValues setting is used in bank registration is determined by bank registration request property UseTransportCertificateDnWithStringNotHexDottedDecimalAttributeValues. . This setting is ignored when TransportCertificateType = \"OBLegacy\" . OpenBankingConnector :TransportCertificateProfiles :{Id} :CertificateDnWithStringDottedDecimalAttributeValues where string Id is user-defined profile ID string - Alternative transport certificate DN to use for bank registration (DCR) with string (not hex) values for dotted-decimal attributes (required by some banks). Whether ertificateDnWithHexDottedDecimalAttributeValues setting or CertificateDnWithStringDottedDecimalAttributeValues setting is used in bank registration is determined by bank registration request property UseTransportCertificateDnWithStringNotHexDottedDecimalAttributeValues. This setting is ignored when TransportCertificateType = \"OBLegacy\" . OpenBankingConnector :TransportCertificateProfiles :{Id} :AssociatedKey where string Id is user-defined profile ID string - Transport key (PKCS #8) as \"stringified\" PEM file with escaped newline characters ( \"\\n\" ) and PRIVATE KEY label. Example: \"-----BEGIN PRIVATE KEY-----\\nABC\\n-----END PRIVATE KEY-----\\n\" . OpenBankingConnector :TransportCertificateProfiles :{Id} :Certificate where string Id is user-defined profile ID string - Transport certificate (X.509) as \"stringified\" PEM file with escaped newline characters ( \"\\n\" ) and CERTIFICATE label. Example: \"-----BEGIN CERTIFICATE-----\\nABC\\n-----END CERTIFICATE-----\\n\" .","title":"Settings"},{"location":"contributor-info/","text":"Contributor info Open Banking Connector is an open-source project and welcomes contributions. [To be updated with more info re. contriubtions] See the following sections for contributor guidance on: documentation","title":"Contributor info"},{"location":"contributor-info/#contributor-info","text":"Open Banking Connector is an open-source project and welcomes contributions. [To be updated with more info re. contriubtions] See the following sections for contributor guidance on: documentation","title":"Contributor info"},{"location":"contributor-info/documentation/","text":"Documentation This section provides contributor information both on creating documentation and publishing it to the docs website . Documentation is written in Markdown and stored in the docs folder in the repo. The documentation is available publicly: on the GitHub repo pages (reflects latest commits) on the docs website (reflects capture of documentation most recently pushed to gh_pages branch) We here provide guidance for - updating documentation in the docs folder - deploying documentation from the docs folder to the docs website .","title":"Documentation"},{"location":"contributor-info/documentation/#documentation","text":"This section provides contributor information both on creating documentation and publishing it to the docs website . Documentation is written in Markdown and stored in the docs folder in the repo. The documentation is available publicly: on the GitHub repo pages (reflects latest commits) on the docs website (reflects capture of documentation most recently pushed to gh_pages branch) We here provide guidance for - updating documentation in the docs folder - deploying documentation from the docs folder to the docs website .","title":"Documentation"},{"location":"contributor-info/documentation/deploy-documentation/","text":"Deploy documentation Here are the steps required to: prepare for deployment deploy documentation to website Pre-requisites To publish documentation to the website, you will need to have permission to push to the gh-pages branch of the repo. You will need to install Python 3 and Material for MkDocs (mkdocs-material). Assuming you have installed Python, you can install Material for MkDocs as follows: pip install mkdocs-material # if mkdocs-material not installed pip install mkdocs-git-revision-date-plugin Prepare for deployment Preview website To deploy the website locally for inspection and testing, please cd to the OBC repo root and run the following command: mkdocs serve This will return the URL you can use to see the website. Decide on docs version and create a tag Everytime website is regenerated, point links to a new tag: decide on a version number create tag based on version number git tag \"docs_v1.0\" push tag to github git push publicRemote docs_v1.0 Github tags are used to create a version number for a new release. This separates different versions of code and links depending on the version. Create overview page (temporary change - do not commit) For the overview page on the website, an overview folder with a README.md was created for the website heading feature. This is not compatible with Github so this folder was added to .gitignore to stop it from being committed. There is a separate project /docs/README.md file which is visible on github. Convert code links to absolute paths (temporary change - do not commit) Relative paths are normally used for links to code in the docs. Example: (https://github.com/finlabsuk/open-banking-connector/blob/docs_v1.5/src/..../BankConfigurationMethods.cs#39) However, before running mkdocs to generate the website, relative links that go outside the docs folder must be converted to absolute links: (https://github.com/finlabsuk/open-banking-connector/blob/docs_v1.0/src/..../BankConfigurationMethods.cs#39). Here is a regular expression search and replace that may help to speed this conversion up (we used this in Visual Studio Code) Search: \\(\\.\\.\\/[\\.\\/]*?src Replace: (https://github.com/finlabsuk/open-banking-connector/blob/docs_v1.5/src Please do not commit these changes to links. Deploy to website Assuming you have permissions to push to the repo gh-pages branch, you can update the public website on GitHub Pages using: mkdocs gh-deploy -m \"Deploy Docs using Tag v1.4\" -r publicRemote - -ignore-version # adjust commit message and remote as required N.B. The --ignore-version flag is used to solve the problem of Mkdocs confusing the tag version with the Mkdocs version which stops the website from being deployed.","title":"Deploy"},{"location":"contributor-info/documentation/deploy-documentation/#deploy-documentation","text":"Here are the steps required to: prepare for deployment deploy documentation to website","title":"Deploy documentation"},{"location":"contributor-info/documentation/deploy-documentation/#pre-requisites","text":"To publish documentation to the website, you will need to have permission to push to the gh-pages branch of the repo. You will need to install Python 3 and Material for MkDocs (mkdocs-material). Assuming you have installed Python, you can install Material for MkDocs as follows: pip install mkdocs-material # if mkdocs-material not installed pip install mkdocs-git-revision-date-plugin","title":"Pre-requisites"},{"location":"contributor-info/documentation/deploy-documentation/#prepare-for-deployment","text":"","title":"Prepare for deployment"},{"location":"contributor-info/documentation/deploy-documentation/#preview-website","text":"To deploy the website locally for inspection and testing, please cd to the OBC repo root and run the following command: mkdocs serve This will return the URL you can use to see the website.","title":"Preview website"},{"location":"contributor-info/documentation/deploy-documentation/#decide-on-docs-version-and-create-a-tag","text":"Everytime website is regenerated, point links to a new tag: decide on a version number create tag based on version number git tag \"docs_v1.0\" push tag to github git push publicRemote docs_v1.0 Github tags are used to create a version number for a new release. This separates different versions of code and links depending on the version.","title":"Decide on docs version and create a tag"},{"location":"contributor-info/documentation/deploy-documentation/#create-overview-page-temporary-change-do-not-commit","text":"For the overview page on the website, an overview folder with a README.md was created for the website heading feature. This is not compatible with Github so this folder was added to .gitignore to stop it from being committed. There is a separate project /docs/README.md file which is visible on github.","title":"Create overview page (temporary change - do not commit)"},{"location":"contributor-info/documentation/deploy-documentation/#convert-code-links-to-absolute-paths-temporary-change-do-not-commit","text":"Relative paths are normally used for links to code in the docs. Example: (https://github.com/finlabsuk/open-banking-connector/blob/docs_v1.5/src/..../BankConfigurationMethods.cs#39) However, before running mkdocs to generate the website, relative links that go outside the docs folder must be converted to absolute links: (https://github.com/finlabsuk/open-banking-connector/blob/docs_v1.0/src/..../BankConfigurationMethods.cs#39). Here is a regular expression search and replace that may help to speed this conversion up (we used this in Visual Studio Code) Search: \\(\\.\\.\\/[\\.\\/]*?src Replace: (https://github.com/finlabsuk/open-banking-connector/blob/docs_v1.5/src Please do not commit these changes to links.","title":"Convert code links to absolute paths (temporary change - do not commit)"},{"location":"contributor-info/documentation/deploy-documentation/#deploy-to-website","text":"Assuming you have permissions to push to the repo gh-pages branch, you can update the public website on GitHub Pages using: mkdocs gh-deploy -m \"Deploy Docs using Tag v1.4\" -r publicRemote - -ignore-version # adjust commit message and remote as required N.B. The --ignore-version flag is used to solve the problem of Mkdocs confusing the tag version with the Mkdocs version which stops the website from being deployed.","title":"Deploy to website"},{"location":"contributor-info/documentation/update-documentation/","text":"Update documentation Here are the steps required to: update current documentation using markdown add new documentation Update documentation To update the current documentation: edit the required files in the /docs repo folder Any changes made must be applied to the nav section in the mkdocs.yml . (e.g. file/folder rename or file structure changes) Links to content in the repo must be relative links. For example: [Page](./page.md) The next step is to generate docs website and deploy documentation. Add new documentation To add new documentation: create new folder in /docs repo folder create new README.md file inside the folder create file.md file In mkdocs.yml , the nav section must include your changes: nav: - SectionTitle: - folder/file.md - PageTitle: file.md The next step is to generate docs website and deploy documentation.","title":"Update"},{"location":"contributor-info/documentation/update-documentation/#update-documentation","text":"Here are the steps required to: update current documentation using markdown add new documentation","title":"Update documentation"},{"location":"contributor-info/documentation/update-documentation/#update-documentation_1","text":"To update the current documentation: edit the required files in the /docs repo folder Any changes made must be applied to the nav section in the mkdocs.yml . (e.g. file/folder rename or file structure changes) Links to content in the repo must be relative links. For example: [Page](./page.md) The next step is to generate docs website and deploy documentation.","title":"Update documentation"},{"location":"contributor-info/documentation/update-documentation/#add-new-documentation","text":"To add new documentation: create new folder in /docs repo folder create new README.md file inside the folder create file.md file In mkdocs.yml , the nav section must include your changes: nav: - SectionTitle: - folder/file.md - PageTitle: file.md The next step is to generate docs website and deploy documentation.","title":"Add new documentation"},{"location":"get-started/","text":"Get Started Open Banking Connector is a collection of C# class libraries provided as packages in Nuget. Overview In order to use Open Banking Connector in your C# Open Banking application you will need to: Select a package from Nuget and include it in your application The following additional setup steps are also required and might differ between development, staging and production environments: Install the UK Open Banking root certificate Configure settings for Open Banking Connector including a database connection string Configure secrets for Open Banking Connector including software statements and Open Banking certificates You can then use Open Banking Connector's interface within your application. Please see interface docs for examples of simple tasks such as configuring a bank (including registration creation) and creating a payment consent etc. Select a Nuget package The following Open Banking Connector packages are available and you should select one based on the type of app that will include it. App Type Nuget Package \"Plain\" app (no .NET Generic Host) FinnovationLabs.OpenBanking.Library.Connector .NET Generic Host app FinnovationLabs.OpenBanking.Library.Connector.GenericHost .NET Generic Host app (Azure-hosted) ASP.NET Core app FinnovationLabs.OpenBanking.Library.Connector.Web You will also need to consider how you will handle bank authentication redirects. You can handle these externally to Open Banking Connector and provide authentication results via its Fluent interface. Or, if you use FinnovationLabs.OpenBanking.Library.Connector.Web in an ASP.NET Core app, Open Banking Connector provides web endpoints to absorb authentication redirects. Install the UK Open Banking root certificate For a development environment, please follow instructions here . For staging/production environment, please follow your internal procedures. Configure settings Open Banking Connector is configured by settings which e.g. provide a database connection string and limits which SoftwareStatementProfiles are loaded. More information is provided here. Configure secrets Open Banking Connector is also configured by secrets which provide sensitive information such as SoftwareStatementProfiles and ObCertificateProfiles. More information is provided here.","title":"Get Started"},{"location":"get-started/#get-started","text":"Open Banking Connector is a collection of C# class libraries provided as packages in Nuget.","title":"Get Started"},{"location":"get-started/#overview","text":"In order to use Open Banking Connector in your C# Open Banking application you will need to: Select a package from Nuget and include it in your application The following additional setup steps are also required and might differ between development, staging and production environments: Install the UK Open Banking root certificate Configure settings for Open Banking Connector including a database connection string Configure secrets for Open Banking Connector including software statements and Open Banking certificates You can then use Open Banking Connector's interface within your application. Please see interface docs for examples of simple tasks such as configuring a bank (including registration creation) and creating a payment consent etc.","title":"Overview"},{"location":"get-started/#select-a-nuget-package","text":"The following Open Banking Connector packages are available and you should select one based on the type of app that will include it. App Type Nuget Package \"Plain\" app (no .NET Generic Host) FinnovationLabs.OpenBanking.Library.Connector .NET Generic Host app FinnovationLabs.OpenBanking.Library.Connector.GenericHost .NET Generic Host app (Azure-hosted) ASP.NET Core app FinnovationLabs.OpenBanking.Library.Connector.Web You will also need to consider how you will handle bank authentication redirects. You can handle these externally to Open Banking Connector and provide authentication results via its Fluent interface. Or, if you use FinnovationLabs.OpenBanking.Library.Connector.Web in an ASP.NET Core app, Open Banking Connector provides web endpoints to absorb authentication redirects.","title":"Select a Nuget package"},{"location":"get-started/#install-the-uk-open-banking-root-certificate","text":"For a development environment, please follow instructions here . For staging/production environment, please follow your internal procedures.","title":"Install the UK Open Banking root certificate"},{"location":"get-started/#configure-settings","text":"Open Banking Connector is configured by settings which e.g. provide a database connection string and limits which SoftwareStatementProfiles are loaded. More information is provided here.","title":"Configure settings"},{"location":"get-started/#configure-secrets","text":"Open Banking Connector is also configured by secrets which provide sensitive information such as SoftwareStatementProfiles and ObCertificateProfiles. More information is provided here.","title":"Configure secrets"},{"location":"get-started/configure-secrets/","text":"Setting up a software statement profile in secrets storage OBC uses key secrets to store sensitive data such as software statment profiles. A software statement profile consists of a software statement (created in the UK Open Banking directory) and associated information (keys, certificates, etc). Each software statement identifies a third-party entity that can create registrations (clients) with banks. To use OBC, at least one software statement profile must be provided in secrets storage. This will allow the creation of bank registrations and is a pre-requisite for using OBC. During development, it is suggested to use the ASP.NET Core Secret Manager as the OBC secrets store. This is a local secrets.json file stored outside of the project and well away from your Git repo (!). This page explains how to add a software statement profile to the ASP.NET Core Secret Manager. Software statement profile secrets The structure of a software statement profile is given and documented by the C# class FinnovationLabs.OpenBanking.Library.Connector.Configuration.SoftwareStatementProfile . Each property of this class is a string and corresponds to a single secret. To specify a software statement profile via secrets, you will need to decide upon an ID for the profile and then create secrets using the key format SoftwareStatementProfiles:<Profile ID>:<C# Property Name> . For example, here is JSON specifying secrets for a software statement profile with ID All : { \"SoftwareStatementProfiles:All:CertificateType\" : \"LegacyOB\" , \"SoftwareStatementProfiles:All:SigningKeyId\" : \"mySigningKeyId\" , \"SoftwareStatementProfiles:All:SigningKey\" : \"-----BEGIN PRIVATE KEY-----\\nmyKeyLine1\\nmyKeyLine2\\n-----END PRIVATE KEY-----\\n\" , \"SoftwareStatementProfiles:All:SigningCertificate\" : \"-----BEGIN CERTIFICATE-----\\nmyCertLine1\\nmyCertLine2\\n-----END CERTIFICATE-----\\n\" , \"SoftwareStatementProfiles:All:TransportKey\" : \"-----BEGIN PRIVATE KEY-----\\nmyKeyLine1\\nmyKeyLine2\\n-----END PRIVATE KEY-----\\n\" , \"SoftwareStatementProfiles:All:TransportCertificate\" : \"-----BEGIN CERTIFICATE-----\\nmyCertLine1\\nmyCertLine2\\n-----END CERTIFICATE-----\\n\" , \"SoftwareStatementProfiles:All:SoftwareStatement\" : \"mySoftwareStatementPart1.mySoftwareStatementPart2.mySoftwareStatementPart3\" , \"SoftwareStatementProfiles:All:DefaultFragmentRedirectUrl\" : \"https://example.com/auth/fragment-redirect\" } Adding a software statement profile to the ASP.NET Core Secret Manager To add a software statement profile to the ASP.NET Core Secret Manager, first create a secrets.json file with JSON specifying your software statement profile secrets (see previous section). Then place this file in a new secrets folder named the same as the UserSecretsId . The default UserSecretsId for OBC is currently specified in applicable .csproj files as: <UserSecretsId> aa921213-9461-4f9e-8fec-153624ec67ad </UserSecretsId> This secrets folder should be created in the Microsoft UserSecrets folder appropriate for your platform. (Note: Please also remember to supply the IDs of active software statement profiles to OBC via configuration.)","title":"Configure Secrets"},{"location":"get-started/configure-secrets/#setting-up-a-software-statement-profile-in-secrets-storage","text":"OBC uses key secrets to store sensitive data such as software statment profiles. A software statement profile consists of a software statement (created in the UK Open Banking directory) and associated information (keys, certificates, etc). Each software statement identifies a third-party entity that can create registrations (clients) with banks. To use OBC, at least one software statement profile must be provided in secrets storage. This will allow the creation of bank registrations and is a pre-requisite for using OBC. During development, it is suggested to use the ASP.NET Core Secret Manager as the OBC secrets store. This is a local secrets.json file stored outside of the project and well away from your Git repo (!). This page explains how to add a software statement profile to the ASP.NET Core Secret Manager.","title":"Setting up a software statement profile in secrets storage"},{"location":"get-started/configure-secrets/#software-statement-profile-secrets","text":"The structure of a software statement profile is given and documented by the C# class FinnovationLabs.OpenBanking.Library.Connector.Configuration.SoftwareStatementProfile . Each property of this class is a string and corresponds to a single secret. To specify a software statement profile via secrets, you will need to decide upon an ID for the profile and then create secrets using the key format SoftwareStatementProfiles:<Profile ID>:<C# Property Name> . For example, here is JSON specifying secrets for a software statement profile with ID All : { \"SoftwareStatementProfiles:All:CertificateType\" : \"LegacyOB\" , \"SoftwareStatementProfiles:All:SigningKeyId\" : \"mySigningKeyId\" , \"SoftwareStatementProfiles:All:SigningKey\" : \"-----BEGIN PRIVATE KEY-----\\nmyKeyLine1\\nmyKeyLine2\\n-----END PRIVATE KEY-----\\n\" , \"SoftwareStatementProfiles:All:SigningCertificate\" : \"-----BEGIN CERTIFICATE-----\\nmyCertLine1\\nmyCertLine2\\n-----END CERTIFICATE-----\\n\" , \"SoftwareStatementProfiles:All:TransportKey\" : \"-----BEGIN PRIVATE KEY-----\\nmyKeyLine1\\nmyKeyLine2\\n-----END PRIVATE KEY-----\\n\" , \"SoftwareStatementProfiles:All:TransportCertificate\" : \"-----BEGIN CERTIFICATE-----\\nmyCertLine1\\nmyCertLine2\\n-----END CERTIFICATE-----\\n\" , \"SoftwareStatementProfiles:All:SoftwareStatement\" : \"mySoftwareStatementPart1.mySoftwareStatementPart2.mySoftwareStatementPart3\" , \"SoftwareStatementProfiles:All:DefaultFragmentRedirectUrl\" : \"https://example.com/auth/fragment-redirect\" }","title":"Software statement profile secrets"},{"location":"get-started/configure-secrets/#adding-a-software-statement-profile-to-the-aspnet-core-secret-manager","text":"To add a software statement profile to the ASP.NET Core Secret Manager, first create a secrets.json file with JSON specifying your software statement profile secrets (see previous section). Then place this file in a new secrets folder named the same as the UserSecretsId . The default UserSecretsId for OBC is currently specified in applicable .csproj files as: <UserSecretsId> aa921213-9461-4f9e-8fec-153624ec67ad </UserSecretsId> This secrets folder should be created in the Microsoft UserSecrets folder appropriate for your platform. (Note: Please also remember to supply the IDs of active software statement profiles to OBC via configuration.)","title":"Adding a software statement profile to the ASP.NET Core Secret Manager"},{"location":"get-started/configure-settings/","text":"Configure Open Banking Connector settings Settings are used to configure Open Bankinng Connector alongside secrets which provide sensitive configuration data. They are organised into groups defined by C# classes. They can be provided in various forms depending on the type of app using Open Banking Connector. Two groups of settings are currently defined: Group C# class Description Open Banking Connector OpenBankingConnectorSettings settings related to Core Open Banking functionality including the database connection string Bank Profile Settings BankProfilesSettings settings related to Bank Profiles which is an optional feature of Open Bnaking Connector providing configuration for UK bank sandboxes Available Settings Group (C# class): Open Banking Connector Setting Example value Description \"SqliteDb ConnectionString\": \"Data Source=../../../../OpenBanking.Library. Connector/sqliteTestDb.db\" This string specifies the type of connection string being used. The path to the .db file will be specified. \"EnsureDbCreated\": \"true\" This settings identifies whether the database has been created. Group (C# class): Bank Profile Settings Setting Example value Description \"DataDirectory\":{ \"Windows\": Specified different OS types. \"Windows\": \"C:/Repos/open-banking-connector-csharp-data/bankProfileData\" Displays the specific path to the data directory for each OS. Configure settings for a \"Plain\" app (app without .NET Generic Host) user has freedom to create settings in any way and use them when creating the Open Banking Connector request object. TODO: Need to set up setting providers for each settings group. (Bank Profile and Open Banking Connector) Configure settings for .NET Generic Host or ASP.NET Core app Microsoft ASP.NET Core is configured using various sources. One configuration method is the use of settings files such as appsettings.json. Please see Microsoft link for more information. The two setting groups can be used to create setting sections in appsettings.json or the settings can be set individually through the use of environment variables. For example: You could add the following to appsettings.json to configure the BankProfileSettings settings group. \"BankProfiles\" : { \"DataDirectory\" : { \"Windows\" : \"C:/Repos/open-banking-connector-csharp-data/bankProfileData\" , \"MacOs\" : \"~/Repos/open-banking-connector-csharp-data/bankProfileData\" , \"Linux\" : \"~/Repos/open-banking-connector-csharp-data/bankProfileData\" } } Refer to Microsoft link for more examples of how the C# code maps to the AppSettings file.","title":"Configure Settings"},{"location":"get-started/configure-settings/#configure-open-banking-connector-settings","text":"Settings are used to configure Open Bankinng Connector alongside secrets which provide sensitive configuration data. They are organised into groups defined by C# classes. They can be provided in various forms depending on the type of app using Open Banking Connector. Two groups of settings are currently defined: Group C# class Description Open Banking Connector OpenBankingConnectorSettings settings related to Core Open Banking functionality including the database connection string Bank Profile Settings BankProfilesSettings settings related to Bank Profiles which is an optional feature of Open Bnaking Connector providing configuration for UK bank sandboxes","title":"Configure Open Banking Connector settings"},{"location":"get-started/configure-settings/#available-settings","text":"Group (C# class): Open Banking Connector Setting Example value Description \"SqliteDb ConnectionString\": \"Data Source=../../../../OpenBanking.Library. Connector/sqliteTestDb.db\" This string specifies the type of connection string being used. The path to the .db file will be specified. \"EnsureDbCreated\": \"true\" This settings identifies whether the database has been created. Group (C# class): Bank Profile Settings Setting Example value Description \"DataDirectory\":{ \"Windows\": Specified different OS types. \"Windows\": \"C:/Repos/open-banking-connector-csharp-data/bankProfileData\" Displays the specific path to the data directory for each OS.","title":"Available Settings"},{"location":"get-started/configure-settings/#configure-settings-for-a-plain-app-app-without-net-generic-host","text":"user has freedom to create settings in any way and use them when creating the Open Banking Connector request object. TODO: Need to set up setting providers for each settings group. (Bank Profile and Open Banking Connector)","title":"Configure settings for a \"Plain\" app (app without .NET Generic Host)"},{"location":"get-started/configure-settings/#configure-settings-for-net-generic-host-or-aspnet-core-app","text":"Microsoft ASP.NET Core is configured using various sources. One configuration method is the use of settings files such as appsettings.json. Please see Microsoft link for more information. The two setting groups can be used to create setting sections in appsettings.json or the settings can be set individually through the use of environment variables. For example: You could add the following to appsettings.json to configure the BankProfileSettings settings group. \"BankProfiles\" : { \"DataDirectory\" : { \"Windows\" : \"C:/Repos/open-banking-connector-csharp-data/bankProfileData\" , \"MacOs\" : \"~/Repos/open-banking-connector-csharp-data/bankProfileData\" , \"Linux\" : \"~/Repos/open-banking-connector-csharp-data/bankProfileData\" } } Refer to Microsoft link for more examples of how the C# code maps to the AppSettings file.","title":"Configure settings for .NET Generic Host or ASP.NET Core app"},{"location":"get-started/dev-environment/install-ob-root-cert/","text":"Install Open Banking Root Certificate An Open Banking UK root certificate needs to be installed to check remote certs from banks when creating SSL connections. Obtain the Root Certificate The UK Open Baking Sandbox root certificate can be obtained here . Currently only the Open Banking UK root certificate (and not the issuing certificate) needs to be installed. Install the Root Certificate On Windows, open the certificate manager (certlm.msc) and right-click \"Trusted Root Certification Authorities / Certificates\" and choose to import the certificate. On macOS (Big Sur), double-click the cert to add to the System Keychain and right-click to enable \"Always Trust\".","title":"Install OB Root Cerftificate"},{"location":"get-started/dev-environment/install-ob-root-cert/#install-open-banking-root-certificate","text":"An Open Banking UK root certificate needs to be installed to check remote certs from banks when creating SSL connections.","title":"Install Open Banking Root Certificate"},{"location":"get-started/dev-environment/install-ob-root-cert/#obtain-the-root-certificate","text":"The UK Open Baking Sandbox root certificate can be obtained here . Currently only the Open Banking UK root certificate (and not the issuing certificate) needs to be installed.","title":"Obtain the Root Certificate"},{"location":"get-started/dev-environment/install-ob-root-cert/#install-the-root-certificate","text":"On Windows, open the certificate manager (certlm.msc) and right-click \"Trusted Root Certification Authorities / Certificates\" and choose to import the certificate. On macOS (Big Sur), double-click the cert to add to the System Keychain and right-click to enable \"Always Trust\".","title":"Install the Root Certificate"},{"location":"how-to/set-up-software-statement-profiles/","text":"How to: Set up software statement profiles In UK Open Banking, a software statement is used to identify the entity (the \"TPP\") connecting to the bank. A software statement may for example may be created in the UK Open Banking directory. A software statement and associated information (keys, certificates, etc) are represented in Open Banking Connector (OBC) as a Software Statement Profile . The data that forms a software statement profile is shown below. Each bank registration is based on a software statment profile and so it is necessary to set one up before attempting to create a bank registration. Setting up a software statement profile is essentially a pre-requisite for use of OBC. Software statement profiles are provided to OBC via a secret provider as they contain very sensitive information. Although multiple software statement profiles can be provided, currently only one can be active (in use concurrently). We hope to relax this requirement in future. Development set-up and secrets structure For development purposes Microsoft's Secret Manager (i.e. a secrets.json file) can be used (see Microsoft's documentation for their Secrets Manager). The default UserSecretsId for OBC is currently specified in applicable .csproj files as: <UserSecretsId> aa921213-9461-4f9e-8fec-153624ec67ad </UserSecretsId> Basically to set things up with a secrets.json file you need to create a secrets folder with the name aa921213-9461-4f9e-8fec-153624ec67ad in the Microsoft UserSecrets folder for your platform and then place a secrets.json file for OBC there. Secrets used by OBC are always strings. Software statement profiles should be specified as secrets as shown in this example secrets.json file: { \"active-software-statement-profiles:profile-ids\" : \"0\" , \"software-statement-profile:0:signing-key-id\" : \"mySigningKeyId\" , \"software-statement-profile:0:signing-key\" : \"-----BEGIN PRIVATE KEY-----\\nmyKeyLine1\\nmyKeyLine2\\n-----END PRIVATE KEY-----\\n\" , \"software-statement-profile:0:signing-certificate\" : \"-----BEGIN CERTIFICATE-----\\nmyCertLine1\\nmyCertLine2\\n-----END CERTIFICATE-----\\n\" , \"software-statement-profile:0:transport-key\" : \"-----BEGIN PRIVATE KEY-----\\nmyKeyLine1\\nmyKeyLine2\\n-----END PRIVATE KEY-----\\n\" , \"software-statement-profile:0:transport-certificate\" : \"-----BEGIN CERTIFICATE-----\\nmyCertLine1\\nmyCertLine2\\n-----END CERTIFICATE-----\\n\" , \"software-statement-profile:0:software-statement\" : \"mySoftwareStatementPart1.mySoftwareStatementPart2.mySoftwareStatementPart3\" , \"software-statement-profile:0:default-fragment-redirect-url\" : \"https://example.com/auth/fragment-redirect\" , \"software-statement-profile:1:signing-key-id\" : \"mySigningKeyId\" , \"software-statement-profile:1:signing-key\" : \"-----BEGIN PRIVATE KEY-----\\nmyKeyLine1\\nmyKeyLine2\\n-----END PRIVATE KEY-----\\n\" , \"software-statement-profile:1:signing-certificate\" : \"-----BEGIN CERTIFICATE-----\\nmyCertLine1\\nmyCertLine2\\n-----END CERTIFICATE-----\\n\" , \"software-statement-profile:1:transport-key\" : \"-----BEGIN PRIVATE KEY-----\\nmyKeyLine1\\nmyKeyLine2\\n-----END PRIVATE KEY-----\\n\" , \"software-statement-profile:1:transport-certificate\" : \"-----BEGIN CERTIFICATE-----\\nmyCertLine1\\nmyCertLine2\\n-----END CERTIFICATE-----\\n\" , \"software-statement-profile:1:software-statement\" : \"mySoftwareStatementPart1.mySoftwareStatementPart2.mySoftwareStatementPart3\" , \"software-statement-profile:1:default-fragment-redirect-url\" : \"https://example.com/auth/fragment-redirect\" } Here two software statment profiles are specified (with IDs 0 and 1 ). active-software-statement-profiles:profile-ids must refer to the (for now single ) ID of a specified software statement (i.e. either 0 or 1 in the above example) and specifies which software statement profile is active. Any attempt to (a) use a non-active software statement profile when creating a bank registration in OBC, or (b) do anything based on a bank registration created with a non-active software statement in OBC will result in an error. Production set-up [TODO]","title":"How to: Set up software statement profiles"},{"location":"how-to/set-up-software-statement-profiles/#how-to-set-up-software-statement-profiles","text":"In UK Open Banking, a software statement is used to identify the entity (the \"TPP\") connecting to the bank. A software statement may for example may be created in the UK Open Banking directory. A software statement and associated information (keys, certificates, etc) are represented in Open Banking Connector (OBC) as a Software Statement Profile . The data that forms a software statement profile is shown below. Each bank registration is based on a software statment profile and so it is necessary to set one up before attempting to create a bank registration. Setting up a software statement profile is essentially a pre-requisite for use of OBC. Software statement profiles are provided to OBC via a secret provider as they contain very sensitive information. Although multiple software statement profiles can be provided, currently only one can be active (in use concurrently). We hope to relax this requirement in future.","title":"How to: Set up software statement profiles"},{"location":"how-to/set-up-software-statement-profiles/#development-set-up-and-secrets-structure","text":"For development purposes Microsoft's Secret Manager (i.e. a secrets.json file) can be used (see Microsoft's documentation for their Secrets Manager). The default UserSecretsId for OBC is currently specified in applicable .csproj files as: <UserSecretsId> aa921213-9461-4f9e-8fec-153624ec67ad </UserSecretsId> Basically to set things up with a secrets.json file you need to create a secrets folder with the name aa921213-9461-4f9e-8fec-153624ec67ad in the Microsoft UserSecrets folder for your platform and then place a secrets.json file for OBC there. Secrets used by OBC are always strings. Software statement profiles should be specified as secrets as shown in this example secrets.json file: { \"active-software-statement-profiles:profile-ids\" : \"0\" , \"software-statement-profile:0:signing-key-id\" : \"mySigningKeyId\" , \"software-statement-profile:0:signing-key\" : \"-----BEGIN PRIVATE KEY-----\\nmyKeyLine1\\nmyKeyLine2\\n-----END PRIVATE KEY-----\\n\" , \"software-statement-profile:0:signing-certificate\" : \"-----BEGIN CERTIFICATE-----\\nmyCertLine1\\nmyCertLine2\\n-----END CERTIFICATE-----\\n\" , \"software-statement-profile:0:transport-key\" : \"-----BEGIN PRIVATE KEY-----\\nmyKeyLine1\\nmyKeyLine2\\n-----END PRIVATE KEY-----\\n\" , \"software-statement-profile:0:transport-certificate\" : \"-----BEGIN CERTIFICATE-----\\nmyCertLine1\\nmyCertLine2\\n-----END CERTIFICATE-----\\n\" , \"software-statement-profile:0:software-statement\" : \"mySoftwareStatementPart1.mySoftwareStatementPart2.mySoftwareStatementPart3\" , \"software-statement-profile:0:default-fragment-redirect-url\" : \"https://example.com/auth/fragment-redirect\" , \"software-statement-profile:1:signing-key-id\" : \"mySigningKeyId\" , \"software-statement-profile:1:signing-key\" : \"-----BEGIN PRIVATE KEY-----\\nmyKeyLine1\\nmyKeyLine2\\n-----END PRIVATE KEY-----\\n\" , \"software-statement-profile:1:signing-certificate\" : \"-----BEGIN CERTIFICATE-----\\nmyCertLine1\\nmyCertLine2\\n-----END CERTIFICATE-----\\n\" , \"software-statement-profile:1:transport-key\" : \"-----BEGIN PRIVATE KEY-----\\nmyKeyLine1\\nmyKeyLine2\\n-----END PRIVATE KEY-----\\n\" , \"software-statement-profile:1:transport-certificate\" : \"-----BEGIN CERTIFICATE-----\\nmyCertLine1\\nmyCertLine2\\n-----END CERTIFICATE-----\\n\" , \"software-statement-profile:1:software-statement\" : \"mySoftwareStatementPart1.mySoftwareStatementPart2.mySoftwareStatementPart3\" , \"software-statement-profile:1:default-fragment-redirect-url\" : \"https://example.com/auth/fragment-redirect\" } Here two software statment profiles are specified (with IDs 0 and 1 ). active-software-statement-profiles:profile-ids must refer to the (for now single ) ID of a specified software statement (i.e. either 0 or 1 in the above example) and specifies which software statement profile is active. Any attempt to (a) use a non-active software statement profile when creating a bank registration in OBC, or (b) do anything based on a bank registration created with a non-active software statement in OBC will result in an error.","title":"Development set-up and secrets structure"},{"location":"how-to/set-up-software-statement-profiles/#production-set-up","text":"[TODO]","title":"Production set-up"},{"location":"interface/","text":"Interface Open Banking Connector is an in-process functional library providing abstract integration with banks. Our aim is to provide a simple, low-risk developer experience to help users make payments and access bank APIs as fast as possible. To this end we will make a DSL via standard C# fluent interface techniques. IRequestBuilder is an injectable .NET type that serves as the DSL's root object. As an example, take the following expression: var resp = await requestBuilder . Payment (). With ( ConsentInfo . FromJwt ( \"<some jwt>\" )) . For ( 123.43 ). Reference ( \"Your payment ref\" ) . From ( AccountInfo . Create ( \"01-02-03\" , \"12345677\" )) . To ( AccountInfo . Create ( \"Joe Bloggs\" , \"02-03-04\" , \"77665544\" )) . Submit (); This interface style is the facade that user code will use.","title":"Interface"},{"location":"interface/#interface","text":"Open Banking Connector is an in-process functional library providing abstract integration with banks. Our aim is to provide a simple, low-risk developer experience to help users make payments and access bank APIs as fast as possible. To this end we will make a DSL via standard C# fluent interface techniques. IRequestBuilder is an injectable .NET type that serves as the DSL's root object. As an example, take the following expression: var resp = await requestBuilder . Payment (). With ( ConsentInfo . FromJwt ( \"<some jwt>\" )) . For ( 123.43 ). Reference ( \"Your payment ref\" ) . From ( AccountInfo . Create ( \"01-02-03\" , \"12345677\" )) . To ( AccountInfo . Create ( \"Joe Bloggs\" , \"02-03-04\" , \"77665544\" )) . Submit (); This interface style is the facade that user code will use.","title":"Interface"},{"location":"interface/bank-configuration/","text":"Bank configuration The BankConfiguration interface allows you to create and read configuration for a bank in Open Banking Connector. The interface consists of three object types on which various methods are supported. Created objects correspond to records in the Open Banking Connector database. To set up a bank, you typically will create a Bank and at least one BankRegistration and one BankApiInformationObject object. More information is provided here . Interface object types The thee bank configuration object types are shown in the table below. Each corresponds to a table in the Open Banking Connector database. Two of the types are local-only and are not created externally at a bank. Objects of BankRegistration type, however, are created externally at a bank as well as having a local database record. Object type Parent type Created at bank? Description Bank N/A No Base object for a bank which includes its IssuerUrl and FinancialId BankApiInformationObject Bank No Object which describes a bank's functional APIs (e.g. PISP). Use multiple objects to allow access to multiple API versions supported by a bank (e.g. multiple versions of PISP), or to test new endpoints etc. BankReistration Bank Yes Object which describes a registration (i.e. OAuth2 client registration) with a bank based on a software statement. Use multiple objects to support multiple registrations with a bank or to test a new registration etc. Supported methods The table below shows the methods supported for each object type as well as the main request and response types for these methods. Methods that include the word \"Local\" operate on the Open Banking Connector database but not at the external bank. Object type Methods Request type Response type Bank GetLocalAsync PostLocalAsync DeleteLocalAsync Bank Bank BankRegistration PostAsync GetLocalAsync DeleteAsync BankRegistration BankRegistration BankApiInformation GetLocalAsyn PostLocalAsync DeleteLocalAsync BankApiInformation BankApiInformation","title":"Bank configuration"},{"location":"interface/bank-configuration/#bank-configuration","text":"The BankConfiguration interface allows you to create and read configuration for a bank in Open Banking Connector. The interface consists of three object types on which various methods are supported. Created objects correspond to records in the Open Banking Connector database. To set up a bank, you typically will create a Bank and at least one BankRegistration and one BankApiInformationObject object. More information is provided here .","title":"Bank configuration"},{"location":"interface/bank-configuration/#interface-object-types","text":"The thee bank configuration object types are shown in the table below. Each corresponds to a table in the Open Banking Connector database. Two of the types are local-only and are not created externally at a bank. Objects of BankRegistration type, however, are created externally at a bank as well as having a local database record. Object type Parent type Created at bank? Description Bank N/A No Base object for a bank which includes its IssuerUrl and FinancialId BankApiInformationObject Bank No Object which describes a bank's functional APIs (e.g. PISP). Use multiple objects to allow access to multiple API versions supported by a bank (e.g. multiple versions of PISP), or to test new endpoints etc. BankReistration Bank Yes Object which describes a registration (i.e. OAuth2 client registration) with a bank based on a software statement. Use multiple objects to support multiple registrations with a bank or to test a new registration etc.","title":"Interface object types"},{"location":"interface/bank-configuration/#supported-methods","text":"The table below shows the methods supported for each object type as well as the main request and response types for these methods. Methods that include the word \"Local\" operate on the Open Banking Connector database but not at the external bank. Object type Methods Request type Response type Bank GetLocalAsync PostLocalAsync DeleteLocalAsync Bank Bank BankRegistration PostAsync GetLocalAsync DeleteAsync BankRegistration BankRegistration BankApiInformation GetLocalAsyn PostLocalAsync DeleteLocalAsync BankApiInformation BankApiInformation","title":"Supported methods"},{"location":"interface/bank-configuration/set-up-a-bank/","text":"Set up a bank To set up a bank, you need to create: a Bank object at least one BankRegistration object at least one BankApiInformationObject You can take advantage of Bank Profiles to generate request objects to use when creating these. Or you can use completely custom request objects. Example Here is an example of how to set up a bank using a Bank Profile and is based on code in the demo app . First we create a Bank object: // Create Bank request object from Bank Profile Bank bankRequest = bankProfile . BankRequest ( testNameUnique ); // Makes call to Open Banking Connector. Creates objectand stores in database. IFluentResponse < BankResponse > bankResp = await requestBuilder . ClientRegistration . Banks . PostLocalAsync ( bankRequest ); // Response from Open Banking Connector. Guid bankId = bankResp . Data !. Id ; Then we create a BankApiInfromationObject : // Create BankApiInformationObject request object from Bank Profile BankApiInformation apiInformationRequest = bankProfile . BankApiInformationRequest ( testNameUnique , bankId ); // Makes call to Open Banking Connector. Creates object and stores in database. IFluentResponse < BankApiInformationResponse > apiInformationResponse = await requestBuilder . ClientRegistration . BankApiInformationObjects . PostLocalAsync ( apiInformationRequest ); // Response from Open Banking Connector. Guid bankApiInformationId = apiInformationResponse . Data !. Id ; Finally, we create a BankRegistration object: // Create BankRegistration request object from Bank Profile BankRegistration registrationRequest = bankProfile . BankRegistrationRequest ( testNameUnique , bankId , softwareStatementProfileId , registrationScope ); // Makes call to Open Banking Connector. Creates object at bank and stores in database. IFluentResponse < BankRegistrationResponse > registrationResp = await requestBuilder . ClientRegistration . BankRegistrations . PostAsync ( registrationRequest ); // Response from Open Banking Connector. // Returns object with Unique ID. Guid bankRegistrationId = registrationResp . Data !. Id ; We now have set up a bank and are ready to access functional APIs (e.g. PISP).","title":"Setting up a bank"},{"location":"interface/bank-configuration/set-up-a-bank/#set-up-a-bank","text":"To set up a bank, you need to create: a Bank object at least one BankRegistration object at least one BankApiInformationObject You can take advantage of Bank Profiles to generate request objects to use when creating these. Or you can use completely custom request objects.","title":"Set up a bank"},{"location":"interface/bank-configuration/set-up-a-bank/#example","text":"Here is an example of how to set up a bank using a Bank Profile and is based on code in the demo app . First we create a Bank object: // Create Bank request object from Bank Profile Bank bankRequest = bankProfile . BankRequest ( testNameUnique ); // Makes call to Open Banking Connector. Creates objectand stores in database. IFluentResponse < BankResponse > bankResp = await requestBuilder . ClientRegistration . Banks . PostLocalAsync ( bankRequest ); // Response from Open Banking Connector. Guid bankId = bankResp . Data !. Id ; Then we create a BankApiInfromationObject : // Create BankApiInformationObject request object from Bank Profile BankApiInformation apiInformationRequest = bankProfile . BankApiInformationRequest ( testNameUnique , bankId ); // Makes call to Open Banking Connector. Creates object and stores in database. IFluentResponse < BankApiInformationResponse > apiInformationResponse = await requestBuilder . ClientRegistration . BankApiInformationObjects . PostLocalAsync ( apiInformationRequest ); // Response from Open Banking Connector. Guid bankApiInformationId = apiInformationResponse . Data !. Id ; Finally, we create a BankRegistration object: // Create BankRegistration request object from Bank Profile BankRegistration registrationRequest = bankProfile . BankRegistrationRequest ( testNameUnique , bankId , softwareStatementProfileId , registrationScope ); // Makes call to Open Banking Connector. Creates object at bank and stores in database. IFluentResponse < BankRegistrationResponse > registrationResp = await requestBuilder . ClientRegistration . BankRegistrations . PostAsync ( registrationRequest ); // Response from Open Banking Connector. // Returns object with Unique ID. Guid bankRegistrationId = registrationResp . Data !. Id ; We now have set up a bank and are ready to access functional APIs (e.g. PISP).","title":"Example"},{"location":"interface/payment-initiation/","text":"Payment Initiation The PaymentInitiation interface allows you to create and read bank payments in Open Banking Connector. It is based on v3.1.6 of the UK Open Banking Read-Write Payment Initiation API . Please see here for more information on supported APIs. The functionality of the interface is described in the following pages: domestic paymnents","title":"Payment Initiation"},{"location":"interface/payment-initiation/#payment-initiation","text":"The PaymentInitiation interface allows you to create and read bank payments in Open Banking Connector. It is based on v3.1.6 of the UK Open Banking Read-Write Payment Initiation API . Please see here for more information on supported APIs. The functionality of the interface is described in the following pages: domestic paymnents","title":"Payment Initiation"},{"location":"interface/payment-initiation/create-and-authorise-domestic-payment-consent/","text":"Create and Authorise domestic payment consent To set up domestic payment consent, you need to: create a DomesticPaymentConsent [optional] check for funds confirmation create an AuthContext which generates an auth URL let the user authorise the consent using the URL which will generate a redirect either (a) use Open Banking Connector to process the redirect (b) use external software to process the redirect and pass the results to Open Banking Connector Example Here is an example of how to set up the domestic payment consent. The example is based on code in the demo app . First, we create a domenstic payment consent object: // Create domestic payment consent DomesticPaymentConsent domesticPaymentConsentRequest = bankProfile . DomesticPaymentConsentRequest ( bankRegistrationId , bankApiInformationId , DomesticPaymentTypeEnum . PersonToMerchant , Guid . NewGuid (). ToString ( \"N\" ), Guid . NewGuid (). ToString ( \"N\" ), testNameUnique ); // Makes call to Open Banking Connector. Creates objectand stores in database. IFluentResponse < DomesticPaymentConsentResponse > domesticPaymentConsentResp = await requestBuilder . PaymentInitiation . DomesticPaymentConsents . PostAsync ( domesticPaymentConsentRequest ); // Response from Open Banking Connector. Guid domesticPaymentConsentId = domesticPaymentConsentResp . Data !. Id ; Next, get the Domestic Payment Consent Funds Confirmation // GET consent funds confirmation // Makes call to Open Banking Connector. Creates objectand stores in database. IFluentResponse < DomesticPaymentConsentResponse > domesticPaymentConsentResp4 = await requestBuilderNew . PaymentInitiation . DomesticPaymentConsents . GetFundsConfirmationAsync ( domesticPaymentConsentId ); Then, create the Auth Context // POST auth context var authContextRequest = new DomesticPaymentConsentAuthContext { DomesticPaymentConsentId = domesticPaymentConsentId , Name = testNameUnique }; // Makes call to Open Banking Connector. Creates objectand stores in database. IFluentResponse < DomesticPaymentConsentAuthContextPostResponse > authContextResponse = await requestBuilder . PaymentInitiation . DomesticPaymentConsents . AuthContexts . PostLocalAsync ( authContextRequest ); Once a DomesticPaymentConsent has been created and authorised, a domestic payment may be made .","title":"Create and authorise Domestic Payment Consent"},{"location":"interface/payment-initiation/create-and-authorise-domestic-payment-consent/#create-and-authorise-domestic-payment-consent","text":"To set up domestic payment consent, you need to: create a DomesticPaymentConsent [optional] check for funds confirmation create an AuthContext which generates an auth URL let the user authorise the consent using the URL which will generate a redirect either (a) use Open Banking Connector to process the redirect (b) use external software to process the redirect and pass the results to Open Banking Connector","title":"Create and Authorise domestic payment consent"},{"location":"interface/payment-initiation/create-and-authorise-domestic-payment-consent/#example","text":"Here is an example of how to set up the domestic payment consent. The example is based on code in the demo app . First, we create a domenstic payment consent object: // Create domestic payment consent DomesticPaymentConsent domesticPaymentConsentRequest = bankProfile . DomesticPaymentConsentRequest ( bankRegistrationId , bankApiInformationId , DomesticPaymentTypeEnum . PersonToMerchant , Guid . NewGuid (). ToString ( \"N\" ), Guid . NewGuid (). ToString ( \"N\" ), testNameUnique ); // Makes call to Open Banking Connector. Creates objectand stores in database. IFluentResponse < DomesticPaymentConsentResponse > domesticPaymentConsentResp = await requestBuilder . PaymentInitiation . DomesticPaymentConsents . PostAsync ( domesticPaymentConsentRequest ); // Response from Open Banking Connector. Guid domesticPaymentConsentId = domesticPaymentConsentResp . Data !. Id ; Next, get the Domestic Payment Consent Funds Confirmation // GET consent funds confirmation // Makes call to Open Banking Connector. Creates objectand stores in database. IFluentResponse < DomesticPaymentConsentResponse > domesticPaymentConsentResp4 = await requestBuilderNew . PaymentInitiation . DomesticPaymentConsents . GetFundsConfirmationAsync ( domesticPaymentConsentId ); Then, create the Auth Context // POST auth context var authContextRequest = new DomesticPaymentConsentAuthContext { DomesticPaymentConsentId = domesticPaymentConsentId , Name = testNameUnique }; // Makes call to Open Banking Connector. Creates objectand stores in database. IFluentResponse < DomesticPaymentConsentAuthContextPostResponse > authContextResponse = await requestBuilder . PaymentInitiation . DomesticPaymentConsents . AuthContexts . PostLocalAsync ( authContextRequest ); Once a DomesticPaymentConsent has been created and authorised, a domestic payment may be made .","title":"Example"},{"location":"interface/payment-initiation/domestic-payments/","text":"Domestic Payments The Payment Initiation API supports creating and reading domestic payments. Interface object types The three domestic payment object types are shown in the table below. Each corresponds to a table in the Open Banking Connector database. Object type Parent type(s) Created at bank? Description DomesticPayment Consents BankRegistration , BankApiSet Yes Object a user can \"authorise\" to consent to a payment authorisation a domestic payment. DomesticPayments DomesticPaymentConsent Yes Payment object AuthContexts DomesticPaymentConsent No Object which represents a session allowing the user to authorise a consent Supported methods The table below shows the methods supported for each object type as well as the main request and response types for these methods. Methods that include the word \"Local\" operate on the Open Banking Connector database but not at the external bank. Object type Methods Request type Response type DomesticPaymentConsents GetLocalAsync PostAsync DeleteLocalAsync GetAsync GetFundsConfirmationAsync Consent Consent DomesticPayments GetAsync PostAsync GetLocalAsync DeleteAsync Payment Payment AuthContexts Auth Auth","title":"Domestic Payments"},{"location":"interface/payment-initiation/domestic-payments/#domestic-payments","text":"The Payment Initiation API supports creating and reading domestic payments.","title":"Domestic Payments"},{"location":"interface/payment-initiation/domestic-payments/#interface-object-types","text":"The three domestic payment object types are shown in the table below. Each corresponds to a table in the Open Banking Connector database. Object type Parent type(s) Created at bank? Description DomesticPayment Consents BankRegistration , BankApiSet Yes Object a user can \"authorise\" to consent to a payment authorisation a domestic payment. DomesticPayments DomesticPaymentConsent Yes Payment object AuthContexts DomesticPaymentConsent No Object which represents a session allowing the user to authorise a consent","title":"Interface object types"},{"location":"interface/payment-initiation/domestic-payments/#supported-methods","text":"The table below shows the methods supported for each object type as well as the main request and response types for these methods. Methods that include the word \"Local\" operate on the Open Banking Connector database but not at the external bank. Object type Methods Request type Response type DomesticPaymentConsents GetLocalAsync PostAsync DeleteLocalAsync GetAsync GetFundsConfirmationAsync Consent Consent DomesticPayments GetAsync PostAsync GetLocalAsync DeleteAsync Payment Payment AuthContexts Auth Auth","title":"Supported methods"},{"location":"interface/payment-initiation/make-domestic-payment/","text":"Make Domestic Payment Before making a domestic payment you need to create and authorise a domestic payment consent . You can then make a domestic payment by: using the PostAsync method on requestBuilder.PaymentInitiation.DomesticPayments Example This is an example of how to make a domestic payment. We here create a request object for the domestic payment based on the previously created request object for the domestic payment consent . The required inputs are: domesticPaymentConsentRequest : the consent request object domesticPaymentConsentId : the consent ID testNameUnique : the name field for the payment // Create domestic payment request requestBuilder . Utility . Map ( domesticPaymentConsentRequest . OBWriteDomesticConsent , out PaymentInitiationModelsPublic . OBWriteDomestic2 obWriteDomestic ); // maps Open Banking request objects DomesticPayment domesticPaymentRequest = new DomesticPayment { OBWriteDomestic = obWriteDomestic , DomesticPaymentConsentId = domesticPaymentConsentId , Name = testNameUnique }; // POST domestic payment IFluentResponse < DomesticPaymentResponse > domesticPaymentResponse = await requestBuilder . PaymentInitiation . DomesticPayments . PostAsync ( domesticPaymentRequest ); Guid domesticPaymentId = domesticPaymentResponse . Data !. Id ;","title":"Make Domestic Payments"},{"location":"interface/payment-initiation/make-domestic-payment/#make-domestic-payment","text":"Before making a domestic payment you need to create and authorise a domestic payment consent . You can then make a domestic payment by: using the PostAsync method on requestBuilder.PaymentInitiation.DomesticPayments","title":"Make Domestic Payment"},{"location":"interface/payment-initiation/make-domestic-payment/#example","text":"This is an example of how to make a domestic payment. We here create a request object for the domestic payment based on the previously created request object for the domestic payment consent . The required inputs are: domesticPaymentConsentRequest : the consent request object domesticPaymentConsentId : the consent ID testNameUnique : the name field for the payment // Create domestic payment request requestBuilder . Utility . Map ( domesticPaymentConsentRequest . OBWriteDomesticConsent , out PaymentInitiationModelsPublic . OBWriteDomestic2 obWriteDomestic ); // maps Open Banking request objects DomesticPayment domesticPaymentRequest = new DomesticPayment { OBWriteDomestic = obWriteDomestic , DomesticPaymentConsentId = domesticPaymentConsentId , Name = testNameUnique }; // POST domestic payment IFluentResponse < DomesticPaymentResponse > domesticPaymentResponse = await requestBuilder . PaymentInitiation . DomesticPayments . PostAsync ( domesticPaymentRequest ); Guid domesticPaymentId = domesticPaymentResponse . Data !. Id ;","title":"Example"},{"location":"interface/variable-recurring-payments/","text":"Variable Recurring Payments The VariableRecurringPayments interface allows you to create and read variable recurring bank payments in Open Banking Connector. It is based on v3.1.8 of the UK Open Banking Read-Write Variable Recurring Payments API . The functionality of the interface is described in the following pages: - variable recurring payments","title":"Variable Recurring Payments"},{"location":"interface/variable-recurring-payments/#variable-recurring-payments","text":"The VariableRecurringPayments interface allows you to create and read variable recurring bank payments in Open Banking Connector. It is based on v3.1.8 of the UK Open Banking Read-Write Variable Recurring Payments API . The functionality of the interface is described in the following pages: - variable recurring payments","title":"Variable Recurring Payments"},{"location":"interface/variable-recurring-payments/create-and-authorise-domestic-vrp-consent/","text":"Create and Authorise domestic vrp consent To set up domestic vrp consent, you need to: create a DomesticVrpConsent [optional] check for funds confirmation create an AuthContext which generates an auth URL let the user authorise the consent using the URL which will generate a redirect either (a) use Open Banking Connector to process the redirect (b) use external software to process the redirect and pass the results to Open Banking Connector Example Here is an example of how to set up the domestic vrp consent. The example is based on code in the demo app . First, we create a domestic vrp consent object: // Create domestic VRP consent DomesticVrpConsent domesticVrpConsentRequest = bankProfile . DomesticVrpConsentRequest ( bankRegistrationId , bankApiSetId , domesticVrpTypeEnum , testNameUnique ); // Makes call to Open Banking Connector. Creates objectand stores in database. IFluentResponse < DomesticVrpConsentResponse > domesticVrpConsentResponse = await requestBuilder . VariableRecurringPayments . DomesticVrpConsents . PostAsync ( domesticVrpConsentRequest ); // Response from Open Banking Connector. Guid domesticVrpConsentId = domesticVrpConsentResponse . Data !. Id ; Next, get the Domestic Vrp Consent Funds Confirmation: // GET consent funds confirmation // Makes call to Open Banking Connector. Creates objectand stores in database. IFluentResponse < DomesticVrpConsentResponse > domesticPaymentConsentResp4 = await requestBuilderNew . VariableRecurringPayments . DomesticVrpConsents . GetFundsConfirmationAsync ( domesticVrpConsentId ); Then, create the Auth Context: // POST auth context var authContextRequest = new DomesticVrpConsentAuthContext { DomesticVrpConsentId = domesticVrpConsentId , Name = testNameUnique }; IFluentResponse < DomesticVrpConsentAuthContextPostResponse > authContextResponse = await requestBuilder . VariableRecurringPayments . DomesticVrpConsents . AuthContexts . PostLocalAsync ( authContextRequest ); Once a DomesticPaymentConsent has been created and authorised, a domestic payment may be made .","title":"Create and authorise Domestic VRP Consent"},{"location":"interface/variable-recurring-payments/create-and-authorise-domestic-vrp-consent/#create-and-authorise-domestic-vrp-consent","text":"To set up domestic vrp consent, you need to: create a DomesticVrpConsent [optional] check for funds confirmation create an AuthContext which generates an auth URL let the user authorise the consent using the URL which will generate a redirect either (a) use Open Banking Connector to process the redirect (b) use external software to process the redirect and pass the results to Open Banking Connector","title":"Create and Authorise domestic vrp consent"},{"location":"interface/variable-recurring-payments/create-and-authorise-domestic-vrp-consent/#example","text":"Here is an example of how to set up the domestic vrp consent. The example is based on code in the demo app . First, we create a domestic vrp consent object: // Create domestic VRP consent DomesticVrpConsent domesticVrpConsentRequest = bankProfile . DomesticVrpConsentRequest ( bankRegistrationId , bankApiSetId , domesticVrpTypeEnum , testNameUnique ); // Makes call to Open Banking Connector. Creates objectand stores in database. IFluentResponse < DomesticVrpConsentResponse > domesticVrpConsentResponse = await requestBuilder . VariableRecurringPayments . DomesticVrpConsents . PostAsync ( domesticVrpConsentRequest ); // Response from Open Banking Connector. Guid domesticVrpConsentId = domesticVrpConsentResponse . Data !. Id ; Next, get the Domestic Vrp Consent Funds Confirmation: // GET consent funds confirmation // Makes call to Open Banking Connector. Creates objectand stores in database. IFluentResponse < DomesticVrpConsentResponse > domesticPaymentConsentResp4 = await requestBuilderNew . VariableRecurringPayments . DomesticVrpConsents . GetFundsConfirmationAsync ( domesticVrpConsentId ); Then, create the Auth Context: // POST auth context var authContextRequest = new DomesticVrpConsentAuthContext { DomesticVrpConsentId = domesticVrpConsentId , Name = testNameUnique }; IFluentResponse < DomesticVrpConsentAuthContextPostResponse > authContextResponse = await requestBuilder . VariableRecurringPayments . DomesticVrpConsents . AuthContexts . PostLocalAsync ( authContextRequest ); Once a DomesticPaymentConsent has been created and authorised, a domestic payment may be made .","title":"Example"},{"location":"interface/variable-recurring-payments/domestic-vrps/","text":"Variable Recurring Payments Payment object types The thee payment configuration object types are shown in the table below. Each corresponds to a table in the Open Banking Connector database. Object type Parent type(s) Created at bank? Description DomesticVrp Consents BankRegistration , BankApiSet Yes Object a user can \"authorise\" to consent to a payment authorisation a variable recurring payment. DomesticVrp DomesticVrpConsent Yes Payment object AuthContexts DomesticVrpConsent No Object which represents a session allowing the user to authorise a consent Supported methods The table below shows the methods supported for each object type as well as the main request and response types for these methods. Methods that include the word \"Local\" operate on the Open Banking Connector database but not at the external bank. Object type Methods Request type Response type DomesticVrpConsents GetLocalAsync PostAsync DeleteLocalAsync GetAsync GetFundsConfirmationAsync Consent Consent DomesticPayments GetAsync PostAsync GetLocalAsync DeleteAsync Payment Payment AuthContexts Auth Auth","title":"Domestic VRP"},{"location":"interface/variable-recurring-payments/domestic-vrps/#variable-recurring-payments","text":"","title":"Variable Recurring Payments"},{"location":"interface/variable-recurring-payments/domestic-vrps/#payment-object-types","text":"The thee payment configuration object types are shown in the table below. Each corresponds to a table in the Open Banking Connector database. Object type Parent type(s) Created at bank? Description DomesticVrp Consents BankRegistration , BankApiSet Yes Object a user can \"authorise\" to consent to a payment authorisation a variable recurring payment. DomesticVrp DomesticVrpConsent Yes Payment object AuthContexts DomesticVrpConsent No Object which represents a session allowing the user to authorise a consent","title":"Payment object types"},{"location":"interface/variable-recurring-payments/domestic-vrps/#supported-methods","text":"The table below shows the methods supported for each object type as well as the main request and response types for these methods. Methods that include the word \"Local\" operate on the Open Banking Connector database but not at the external bank. Object type Methods Request type Response type DomesticVrpConsents GetLocalAsync PostAsync DeleteLocalAsync GetAsync GetFundsConfirmationAsync Consent Consent DomesticPayments GetAsync PostAsync GetLocalAsync DeleteAsync Payment Payment AuthContexts Auth Auth","title":"Supported methods"},{"location":"interface/variable-recurring-payments/make-domestic-vrps/","text":"Make Variable Recurring Payments Before making a variable recurring payment you must have created and authorised a consent. You can then make a variable recurring payment by: creating a VariableRecurringPayment reading the VariableRecurringPayment to check its status. using the PostAsync method on requestBuilder.VariableRecurringPayment.DomesticVrpPayments Example Here is an example of how to make a variable recurring payment. We create a domestic vrp request object based on a previously created domestic vrp consent request object. The required inputs are: domesticVrpConsentRequest : the consent request object domesticVrpConsentId : the consent ID testNameUnique : the name field for the payment // Create domestic vrp request requestBuilder . Utility . Map ( domesticVrpConsentRequest . OBDomesticVRPConsentRequest , out VariableRecurringPaymentsModelsPublic . OBDomesticVRPRequest obDomesticVrpRequest ); // maps Open Banking request objects DomesticVrp domesticVrpRequest = new DomesticVrp { OBDomesticVRPRequest = obDomesticVrpRequest , Name = testNameUnique , DomesticVrpConsentId = domesticVrpConsentId , }; // POST domestic VRP IFluentResponse < DomesticVrpResponse > domesticVrpResponse = await requestBuilder . VariableRecurringPayments . DomesticVrps . PostAsync ( domesticVrpRequest ); // Response from Open Banking Connector. Guid domesticVrpId = domesticVrpResponse . Data !. Id ;","title":"Make Domestic VRP"},{"location":"interface/variable-recurring-payments/make-domestic-vrps/#make-variable-recurring-payments","text":"Before making a variable recurring payment you must have created and authorised a consent. You can then make a variable recurring payment by: creating a VariableRecurringPayment reading the VariableRecurringPayment to check its status. using the PostAsync method on requestBuilder.VariableRecurringPayment.DomesticVrpPayments","title":"Make Variable Recurring Payments"},{"location":"interface/variable-recurring-payments/make-domestic-vrps/#example","text":"Here is an example of how to make a variable recurring payment. We create a domestic vrp request object based on a previously created domestic vrp consent request object. The required inputs are: domesticVrpConsentRequest : the consent request object domesticVrpConsentId : the consent ID testNameUnique : the name field for the payment // Create domestic vrp request requestBuilder . Utility . Map ( domesticVrpConsentRequest . OBDomesticVRPConsentRequest , out VariableRecurringPaymentsModelsPublic . OBDomesticVRPRequest obDomesticVrpRequest ); // maps Open Banking request objects DomesticVrp domesticVrpRequest = new DomesticVrp { OBDomesticVRPRequest = obDomesticVrpRequest , Name = testNameUnique , DomesticVrpConsentId = domesticVrpConsentId , }; // POST domestic VRP IFluentResponse < DomesticVrpResponse > domesticVrpResponse = await requestBuilder . VariableRecurringPayments . DomesticVrps . PostAsync ( domesticVrpRequest ); // Response from Open Banking Connector. Guid domesticVrpId = domesticVrpResponse . Data !. Id ;","title":"Example"}]}