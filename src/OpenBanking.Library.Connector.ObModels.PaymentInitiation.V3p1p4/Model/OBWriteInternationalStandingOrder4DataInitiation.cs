/* 
 * Payment Initiation API
 *
 * OpenAPI for Payment Initiation API Specification
 *
 * The version of the OpenAPI document: v3.1.4
 * Contact: ServiceDesk@openbanking.org.uk
 * Generated by: https://github.com/openapitools/openapi-generator.git
 */


using System;
using System.Collections.Generic;
using System.ComponentModel.DataAnnotations;
using System.Linq;
using System.Runtime.Serialization;
using System.Text;
using System.Text.RegularExpressions;
using Newtonsoft.Json;

namespace FinnovationLabs.OpenBanking.Library.Connector.ObModels.PaymentInitiation.V3p1p4.Model
{
    /// <summary>
    /// The Initiation payload is sent by the initiating party to the ASPSP. It is used to request movement of funds from the debtor account to a creditor for an international standing order.
    /// </summary>
    [DataContract]
    public partial class OBWriteInternationalStandingOrder4DataInitiation :  IEquatable<OBWriteInternationalStandingOrder4DataInitiation>, IValidatableObject
    {
        /// <summary>
        /// Gets or Sets ChargeBearer
        /// </summary>
        [DataMember(Name="ChargeBearer", EmitDefaultValue=false)]
        public OBChargeBearerType1Code? ChargeBearer { get; set; }
        /// <summary>
        /// Initializes a new instance of the <see cref="OBWriteInternationalStandingOrder4DataInitiation" /> class.
        /// </summary>
        [JsonConstructor]
        protected OBWriteInternationalStandingOrder4DataInitiation() { }
        /// <summary>
        /// Initializes a new instance of the <see cref="OBWriteInternationalStandingOrder4DataInitiation" /> class.
        /// </summary>
        /// <param name="frequency">Individual Definitions: EvryDay - Every day EvryWorkgDay - Every working day IntrvlWkDay - An interval specified in weeks (01 to 09), and the day within the week (01 to 07) WkInMnthDay - A monthly interval, specifying the week of the month (01 to 05) and day within the week (01 to 07) IntrvlMnthDay - An interval specified in months (between 01 to 06, 12, 24), specifying the day within the month (-5 to -1, 1 to 31) QtrDay - Quarterly (either ENGLISH, SCOTTISH, or RECEIVED).  ENGLISH &#x3D; Paid on the 25th March, 24th June, 29th September and 25th December.  SCOTTISH &#x3D; Paid on the 2nd February, 15th May, 1st August and 11th November. RECEIVED &#x3D; Paid on the 20th March, 19th June, 24th September and 20th December.  Individual Patterns: EvryDay (ScheduleCode) EvryWorkgDay (ScheduleCode) IntrvlWkDay:IntervalInWeeks:DayInWeek (ScheduleCode + IntervalInWeeks + DayInWeek) WkInMnthDay:WeekInMonth:DayInWeek (ScheduleCode + WeekInMonth + DayInWeek) IntrvlMnthDay:IntervalInMonths:DayInMonth (ScheduleCode + IntervalInMonths + DayInMonth) QtrDay: + either (ENGLISH, SCOTTISH or RECEIVED) ScheduleCode + QuarterDay The regular expression for this element combines five smaller versions for each permitted pattern. To aid legibility - the components are presented individually here: EvryDay EvryWorkgDay IntrvlWkDay:0[1-9]:0[1-7] WkInMnthDay:0[1-5]:0[1-7] IntrvlMnthDay:(0[1-6]|12|24):(-0[1-5]|0[1-9]|[12][0-9]|3[01]) QtrDay:(ENGLISH|SCOTTISH|RECEIVED) Full Regular Expression: ^(EvryDay)$|^(EvryWorkgDay)$|^(IntrvlWkDay:0[1-9]:0[1-7])$|^(WkInMnthDay:0[1-5]:0[1-7])$|^(IntrvlMnthDay:(0[1-6]|12|24):(-0[1-5]|0[1-9]|[12][0-9]|3[01]))$|^(QtrDay:(ENGLISH|SCOTTISH|RECEIVED))$ (required).</param>
        /// <param name="reference">Unique reference, as assigned by the creditor, to unambiguously refer to the payment transaction. Usage: If available, the initiating party should provide this reference in the structured remittance information, to enable reconciliation by the creditor upon receipt of the amount of money. If the business context requires the use of a creditor reference or a payment remit identification, and only one identifier can be passed through the end-to-end chain, the creditor&#39;s reference or payment remittance identification should be quoted in the end-to-end transaction identification..</param>
        /// <param name="numberOfPayments">Number of the payments that will be made in completing this frequency sequence including any executed since the sequence start date..</param>
        /// <param name="firstPaymentDateTime">The date on which the first payment for a Standing Order schedule will be made.All dates in the JSON payloads are represented in ISO 8601 date-time format.  All date-time fields in responses must include the timezone. An example is below: 2017-04-05T10:43:07+00:00 (required).</param>
        /// <param name="finalPaymentDateTime">The date on which the final payment for a Standing Order schedule will be made.All dates in the JSON payloads are represented in ISO 8601 date-time format.  All date-time fields in responses must include the timezone. An example is below: 2017-04-05T10:43:07+00:00.</param>
        /// <param name="purpose">Specifies the external purpose code in the format of character string with a maximum length of 4 characters. The list of valid codes is an external code list published separately. External code sets can be downloaded from www.iso20022.org..</param>
        /// <param name="extendedPurpose">Specifies the purpose of an international payment, when there is no corresponding 4 character code available in the ISO20022 list of Purpose Codes..</param>
        /// <param name="chargeBearer">chargeBearer.</param>
        /// <param name="currencyOfTransfer">Specifies the currency of the to be transferred amount, which is different from the currency of the debtor&#39;s account. (required).</param>
        /// <param name="destinationCountryCode">Country in which Credit Account is domiciled. Code to identify a country, a dependency, or another area of particular geopolitical interest, on the basis of country names obtained from the United Nations (ISO 3166, Alpha-2 code)..</param>
        /// <param name="instructedAmount">instructedAmount (required).</param>
        /// <param name="debtorAccount">debtorAccount.</param>
        /// <param name="creditor">creditor.</param>
        /// <param name="creditorAgent">creditorAgent.</param>
        /// <param name="creditorAccount">creditorAccount (required).</param>
        /// <param name="supplementaryData">Additional information that can not be captured in the structured fields and/or any other specific block..</param>
        public OBWriteInternationalStandingOrder4DataInitiation(string frequency = default(string), string reference = default(string), string numberOfPayments = default(string), DateTimeOffset firstPaymentDateTime = default(DateTimeOffset), DateTimeOffset finalPaymentDateTime = default(DateTimeOffset), string purpose = default(string), string extendedPurpose = default(string), OBChargeBearerType1Code? chargeBearer = default(OBChargeBearerType1Code?), string currencyOfTransfer = default(string), string destinationCountryCode = default(string), OBWriteDomestic2DataInitiationInstructedAmount instructedAmount = default(OBWriteDomestic2DataInitiationInstructedAmount), OBWriteDomesticStandingOrder3DataInitiationDebtorAccount debtorAccount = default(OBWriteDomesticStandingOrder3DataInitiationDebtorAccount), OBWriteInternational3DataInitiationCreditor creditor = default(OBWriteInternational3DataInitiationCreditor), OBWriteInternationalStandingOrder4DataInitiationCreditorAgent creditorAgent = default(OBWriteInternationalStandingOrder4DataInitiationCreditorAgent), OBWriteInternationalStandingOrder4DataInitiationCreditorAccount creditorAccount = default(OBWriteInternationalStandingOrder4DataInitiationCreditorAccount), Dictionary<string, Object> supplementaryData = default(Dictionary<string, Object>))
        {
            // to ensure "frequency" is required (not null)
            this.Frequency = frequency ?? throw new ArgumentNullException("frequency is a required property for OBWriteInternationalStandingOrder4DataInitiation and cannot be null");
            this.FirstPaymentDateTime = firstPaymentDateTime;
            // to ensure "currencyOfTransfer" is required (not null)
            this.CurrencyOfTransfer = currencyOfTransfer ?? throw new ArgumentNullException("currencyOfTransfer is a required property for OBWriteInternationalStandingOrder4DataInitiation and cannot be null");
            // to ensure "instructedAmount" is required (not null)
            this.InstructedAmount = instructedAmount ?? throw new ArgumentNullException("instructedAmount is a required property for OBWriteInternationalStandingOrder4DataInitiation and cannot be null");
            // to ensure "creditorAccount" is required (not null)
            this.CreditorAccount = creditorAccount ?? throw new ArgumentNullException("creditorAccount is a required property for OBWriteInternationalStandingOrder4DataInitiation and cannot be null");
            this.Reference = reference;
            this.NumberOfPayments = numberOfPayments;
            this.FinalPaymentDateTime = finalPaymentDateTime;
            this.Purpose = purpose;
            this.ExtendedPurpose = extendedPurpose;
            this.ChargeBearer = chargeBearer;
            this.DestinationCountryCode = destinationCountryCode;
            this.DebtorAccount = debtorAccount;
            this.Creditor = creditor;
            this.CreditorAgent = creditorAgent;
            this.SupplementaryData = supplementaryData;
        }
        
        /// <summary>
        /// Individual Definitions: EvryDay - Every day EvryWorkgDay - Every working day IntrvlWkDay - An interval specified in weeks (01 to 09), and the day within the week (01 to 07) WkInMnthDay - A monthly interval, specifying the week of the month (01 to 05) and day within the week (01 to 07) IntrvlMnthDay - An interval specified in months (between 01 to 06, 12, 24), specifying the day within the month (-5 to -1, 1 to 31) QtrDay - Quarterly (either ENGLISH, SCOTTISH, or RECEIVED).  ENGLISH &#x3D; Paid on the 25th March, 24th June, 29th September and 25th December.  SCOTTISH &#x3D; Paid on the 2nd February, 15th May, 1st August and 11th November. RECEIVED &#x3D; Paid on the 20th March, 19th June, 24th September and 20th December.  Individual Patterns: EvryDay (ScheduleCode) EvryWorkgDay (ScheduleCode) IntrvlWkDay:IntervalInWeeks:DayInWeek (ScheduleCode + IntervalInWeeks + DayInWeek) WkInMnthDay:WeekInMonth:DayInWeek (ScheduleCode + WeekInMonth + DayInWeek) IntrvlMnthDay:IntervalInMonths:DayInMonth (ScheduleCode + IntervalInMonths + DayInMonth) QtrDay: + either (ENGLISH, SCOTTISH or RECEIVED) ScheduleCode + QuarterDay The regular expression for this element combines five smaller versions for each permitted pattern. To aid legibility - the components are presented individually here: EvryDay EvryWorkgDay IntrvlWkDay:0[1-9]:0[1-7] WkInMnthDay:0[1-5]:0[1-7] IntrvlMnthDay:(0[1-6]|12|24):(-0[1-5]|0[1-9]|[12][0-9]|3[01]) QtrDay:(ENGLISH|SCOTTISH|RECEIVED) Full Regular Expression: ^(EvryDay)$|^(EvryWorkgDay)$|^(IntrvlWkDay:0[1-9]:0[1-7])$|^(WkInMnthDay:0[1-5]:0[1-7])$|^(IntrvlMnthDay:(0[1-6]|12|24):(-0[1-5]|0[1-9]|[12][0-9]|3[01]))$|^(QtrDay:(ENGLISH|SCOTTISH|RECEIVED))$
        /// </summary>
        /// <value>Individual Definitions: EvryDay - Every day EvryWorkgDay - Every working day IntrvlWkDay - An interval specified in weeks (01 to 09), and the day within the week (01 to 07) WkInMnthDay - A monthly interval, specifying the week of the month (01 to 05) and day within the week (01 to 07) IntrvlMnthDay - An interval specified in months (between 01 to 06, 12, 24), specifying the day within the month (-5 to -1, 1 to 31) QtrDay - Quarterly (either ENGLISH, SCOTTISH, or RECEIVED).  ENGLISH &#x3D; Paid on the 25th March, 24th June, 29th September and 25th December.  SCOTTISH &#x3D; Paid on the 2nd February, 15th May, 1st August and 11th November. RECEIVED &#x3D; Paid on the 20th March, 19th June, 24th September and 20th December.  Individual Patterns: EvryDay (ScheduleCode) EvryWorkgDay (ScheduleCode) IntrvlWkDay:IntervalInWeeks:DayInWeek (ScheduleCode + IntervalInWeeks + DayInWeek) WkInMnthDay:WeekInMonth:DayInWeek (ScheduleCode + WeekInMonth + DayInWeek) IntrvlMnthDay:IntervalInMonths:DayInMonth (ScheduleCode + IntervalInMonths + DayInMonth) QtrDay: + either (ENGLISH, SCOTTISH or RECEIVED) ScheduleCode + QuarterDay The regular expression for this element combines five smaller versions for each permitted pattern. To aid legibility - the components are presented individually here: EvryDay EvryWorkgDay IntrvlWkDay:0[1-9]:0[1-7] WkInMnthDay:0[1-5]:0[1-7] IntrvlMnthDay:(0[1-6]|12|24):(-0[1-5]|0[1-9]|[12][0-9]|3[01]) QtrDay:(ENGLISH|SCOTTISH|RECEIVED) Full Regular Expression: ^(EvryDay)$|^(EvryWorkgDay)$|^(IntrvlWkDay:0[1-9]:0[1-7])$|^(WkInMnthDay:0[1-5]:0[1-7])$|^(IntrvlMnthDay:(0[1-6]|12|24):(-0[1-5]|0[1-9]|[12][0-9]|3[01]))$|^(QtrDay:(ENGLISH|SCOTTISH|RECEIVED))$</value>
        [DataMember(Name="Frequency", EmitDefaultValue=false)]
        public string Frequency { get; set; }

        /// <summary>
        /// Unique reference, as assigned by the creditor, to unambiguously refer to the payment transaction. Usage: If available, the initiating party should provide this reference in the structured remittance information, to enable reconciliation by the creditor upon receipt of the amount of money. If the business context requires the use of a creditor reference or a payment remit identification, and only one identifier can be passed through the end-to-end chain, the creditor&#39;s reference or payment remittance identification should be quoted in the end-to-end transaction identification.
        /// </summary>
        /// <value>Unique reference, as assigned by the creditor, to unambiguously refer to the payment transaction. Usage: If available, the initiating party should provide this reference in the structured remittance information, to enable reconciliation by the creditor upon receipt of the amount of money. If the business context requires the use of a creditor reference or a payment remit identification, and only one identifier can be passed through the end-to-end chain, the creditor&#39;s reference or payment remittance identification should be quoted in the end-to-end transaction identification.</value>
        [DataMember(Name="Reference", EmitDefaultValue=false)]
        public string Reference { get; set; }

        /// <summary>
        /// Number of the payments that will be made in completing this frequency sequence including any executed since the sequence start date.
        /// </summary>
        /// <value>Number of the payments that will be made in completing this frequency sequence including any executed since the sequence start date.</value>
        [DataMember(Name="NumberOfPayments", EmitDefaultValue=false)]
        public string NumberOfPayments { get; set; }

        /// <summary>
        /// The date on which the first payment for a Standing Order schedule will be made.All dates in the JSON payloads are represented in ISO 8601 date-time format.  All date-time fields in responses must include the timezone. An example is below: 2017-04-05T10:43:07+00:00
        /// </summary>
        /// <value>The date on which the first payment for a Standing Order schedule will be made.All dates in the JSON payloads are represented in ISO 8601 date-time format.  All date-time fields in responses must include the timezone. An example is below: 2017-04-05T10:43:07+00:00</value>
        [DataMember(Name="FirstPaymentDateTime", EmitDefaultValue=false)]
        public DateTimeOffset FirstPaymentDateTime { get; set; }

        /// <summary>
        /// The date on which the final payment for a Standing Order schedule will be made.All dates in the JSON payloads are represented in ISO 8601 date-time format.  All date-time fields in responses must include the timezone. An example is below: 2017-04-05T10:43:07+00:00
        /// </summary>
        /// <value>The date on which the final payment for a Standing Order schedule will be made.All dates in the JSON payloads are represented in ISO 8601 date-time format.  All date-time fields in responses must include the timezone. An example is below: 2017-04-05T10:43:07+00:00</value>
        [DataMember(Name="FinalPaymentDateTime", EmitDefaultValue=false)]
        public DateTimeOffset FinalPaymentDateTime { get; set; }

        /// <summary>
        /// Specifies the external purpose code in the format of character string with a maximum length of 4 characters. The list of valid codes is an external code list published separately. External code sets can be downloaded from www.iso20022.org.
        /// </summary>
        /// <value>Specifies the external purpose code in the format of character string with a maximum length of 4 characters. The list of valid codes is an external code list published separately. External code sets can be downloaded from www.iso20022.org.</value>
        [DataMember(Name="Purpose", EmitDefaultValue=false)]
        public string Purpose { get; set; }

        /// <summary>
        /// Specifies the purpose of an international payment, when there is no corresponding 4 character code available in the ISO20022 list of Purpose Codes.
        /// </summary>
        /// <value>Specifies the purpose of an international payment, when there is no corresponding 4 character code available in the ISO20022 list of Purpose Codes.</value>
        [DataMember(Name="ExtendedPurpose", EmitDefaultValue=false)]
        public string ExtendedPurpose { get; set; }

        /// <summary>
        /// Specifies the currency of the to be transferred amount, which is different from the currency of the debtor&#39;s account.
        /// </summary>
        /// <value>Specifies the currency of the to be transferred amount, which is different from the currency of the debtor&#39;s account.</value>
        [DataMember(Name="CurrencyOfTransfer", EmitDefaultValue=false)]
        public string CurrencyOfTransfer { get; set; }

        /// <summary>
        /// Country in which Credit Account is domiciled. Code to identify a country, a dependency, or another area of particular geopolitical interest, on the basis of country names obtained from the United Nations (ISO 3166, Alpha-2 code).
        /// </summary>
        /// <value>Country in which Credit Account is domiciled. Code to identify a country, a dependency, or another area of particular geopolitical interest, on the basis of country names obtained from the United Nations (ISO 3166, Alpha-2 code).</value>
        [DataMember(Name="DestinationCountryCode", EmitDefaultValue=false)]
        public string DestinationCountryCode { get; set; }

        /// <summary>
        /// Gets or Sets InstructedAmount
        /// </summary>
        [DataMember(Name="InstructedAmount", EmitDefaultValue=false)]
        public OBWriteDomestic2DataInitiationInstructedAmount InstructedAmount { get; set; }

        /// <summary>
        /// Gets or Sets DebtorAccount
        /// </summary>
        [DataMember(Name="DebtorAccount", EmitDefaultValue=false)]
        public OBWriteDomesticStandingOrder3DataInitiationDebtorAccount DebtorAccount { get; set; }

        /// <summary>
        /// Gets or Sets Creditor
        /// </summary>
        [DataMember(Name="Creditor", EmitDefaultValue=false)]
        public OBWriteInternational3DataInitiationCreditor Creditor { get; set; }

        /// <summary>
        /// Gets or Sets CreditorAgent
        /// </summary>
        [DataMember(Name="CreditorAgent", EmitDefaultValue=false)]
        public OBWriteInternationalStandingOrder4DataInitiationCreditorAgent CreditorAgent { get; set; }

        /// <summary>
        /// Gets or Sets CreditorAccount
        /// </summary>
        [DataMember(Name="CreditorAccount", EmitDefaultValue=false)]
        public OBWriteInternationalStandingOrder4DataInitiationCreditorAccount CreditorAccount { get; set; }

        /// <summary>
        /// Additional information that can not be captured in the structured fields and/or any other specific block.
        /// </summary>
        /// <value>Additional information that can not be captured in the structured fields and/or any other specific block.</value>
        [DataMember(Name="SupplementaryData", EmitDefaultValue=false)]
        public Dictionary<string, Object> SupplementaryData { get; set; }

        /// <summary>
        /// Returns the string presentation of the object
        /// </summary>
        /// <returns>String presentation of the object</returns>
        public override string ToString()
        {
            var sb = new StringBuilder();
            sb.Append("class OBWriteInternationalStandingOrder4DataInitiation {\n");
            sb.Append("  Frequency: ").Append(Frequency).Append("\n");
            sb.Append("  Reference: ").Append(Reference).Append("\n");
            sb.Append("  NumberOfPayments: ").Append(NumberOfPayments).Append("\n");
            sb.Append("  FirstPaymentDateTime: ").Append(FirstPaymentDateTime).Append("\n");
            sb.Append("  FinalPaymentDateTime: ").Append(FinalPaymentDateTime).Append("\n");
            sb.Append("  Purpose: ").Append(Purpose).Append("\n");
            sb.Append("  ExtendedPurpose: ").Append(ExtendedPurpose).Append("\n");
            sb.Append("  ChargeBearer: ").Append(ChargeBearer).Append("\n");
            sb.Append("  CurrencyOfTransfer: ").Append(CurrencyOfTransfer).Append("\n");
            sb.Append("  DestinationCountryCode: ").Append(DestinationCountryCode).Append("\n");
            sb.Append("  InstructedAmount: ").Append(InstructedAmount).Append("\n");
            sb.Append("  DebtorAccount: ").Append(DebtorAccount).Append("\n");
            sb.Append("  Creditor: ").Append(Creditor).Append("\n");
            sb.Append("  CreditorAgent: ").Append(CreditorAgent).Append("\n");
            sb.Append("  CreditorAccount: ").Append(CreditorAccount).Append("\n");
            sb.Append("  SupplementaryData: ").Append(SupplementaryData).Append("\n");
            sb.Append("}\n");
            return sb.ToString();
        }
  
        /// <summary>
        /// Returns the JSON string presentation of the object
        /// </summary>
        /// <returns>JSON string presentation of the object</returns>
        public virtual string ToJson()
        {
            return JsonConvert.SerializeObject(this, Formatting.Indented);
        }

        /// <summary>
        /// Returns true if objects are equal
        /// </summary>
        /// <param name="input">Object to be compared</param>
        /// <returns>Boolean</returns>
        public override bool Equals(object input)
        {
            return this.Equals(input as OBWriteInternationalStandingOrder4DataInitiation);
        }

        /// <summary>
        /// Returns true if OBWriteInternationalStandingOrder4DataInitiation instances are equal
        /// </summary>
        /// <param name="input">Instance of OBWriteInternationalStandingOrder4DataInitiation to be compared</param>
        /// <returns>Boolean</returns>
        public bool Equals(OBWriteInternationalStandingOrder4DataInitiation input)
        {
            if (input == null)
                return false;

            return 
                (
                    this.Frequency == input.Frequency ||
                    (this.Frequency != null &&
                    this.Frequency.Equals(input.Frequency))
                ) && 
                (
                    this.Reference == input.Reference ||
                    (this.Reference != null &&
                    this.Reference.Equals(input.Reference))
                ) && 
                (
                    this.NumberOfPayments == input.NumberOfPayments ||
                    (this.NumberOfPayments != null &&
                    this.NumberOfPayments.Equals(input.NumberOfPayments))
                ) && 
                (
                    this.FirstPaymentDateTime == input.FirstPaymentDateTime ||
                    (this.FirstPaymentDateTime != null &&
                    this.FirstPaymentDateTime.Equals(input.FirstPaymentDateTime))
                ) && 
                (
                    this.FinalPaymentDateTime == input.FinalPaymentDateTime ||
                    (this.FinalPaymentDateTime != null &&
                    this.FinalPaymentDateTime.Equals(input.FinalPaymentDateTime))
                ) && 
                (
                    this.Purpose == input.Purpose ||
                    (this.Purpose != null &&
                    this.Purpose.Equals(input.Purpose))
                ) && 
                (
                    this.ExtendedPurpose == input.ExtendedPurpose ||
                    (this.ExtendedPurpose != null &&
                    this.ExtendedPurpose.Equals(input.ExtendedPurpose))
                ) && 
                (
                    this.ChargeBearer == input.ChargeBearer ||
                    this.ChargeBearer.Equals(input.ChargeBearer)
                ) && 
                (
                    this.CurrencyOfTransfer == input.CurrencyOfTransfer ||
                    (this.CurrencyOfTransfer != null &&
                    this.CurrencyOfTransfer.Equals(input.CurrencyOfTransfer))
                ) && 
                (
                    this.DestinationCountryCode == input.DestinationCountryCode ||
                    (this.DestinationCountryCode != null &&
                    this.DestinationCountryCode.Equals(input.DestinationCountryCode))
                ) && 
                (
                    this.InstructedAmount == input.InstructedAmount ||
                    (this.InstructedAmount != null &&
                    this.InstructedAmount.Equals(input.InstructedAmount))
                ) && 
                (
                    this.DebtorAccount == input.DebtorAccount ||
                    (this.DebtorAccount != null &&
                    this.DebtorAccount.Equals(input.DebtorAccount))
                ) && 
                (
                    this.Creditor == input.Creditor ||
                    (this.Creditor != null &&
                    this.Creditor.Equals(input.Creditor))
                ) && 
                (
                    this.CreditorAgent == input.CreditorAgent ||
                    (this.CreditorAgent != null &&
                    this.CreditorAgent.Equals(input.CreditorAgent))
                ) && 
                (
                    this.CreditorAccount == input.CreditorAccount ||
                    (this.CreditorAccount != null &&
                    this.CreditorAccount.Equals(input.CreditorAccount))
                ) && 
                (
                    this.SupplementaryData == input.SupplementaryData ||
                    this.SupplementaryData != null &&
                    input.SupplementaryData != null &&
                    this.SupplementaryData.SequenceEqual(input.SupplementaryData)
                );
        }

        /// <summary>
        /// Gets the hash code
        /// </summary>
        /// <returns>Hash code</returns>
        public override int GetHashCode()
        {
            unchecked // Overflow is fine, just wrap
            {
                int hashCode = 41;
                if (this.Frequency != null)
                    hashCode = hashCode * 59 + this.Frequency.GetHashCode();
                if (this.Reference != null)
                    hashCode = hashCode * 59 + this.Reference.GetHashCode();
                if (this.NumberOfPayments != null)
                    hashCode = hashCode * 59 + this.NumberOfPayments.GetHashCode();
                if (this.FirstPaymentDateTime != null)
                    hashCode = hashCode * 59 + this.FirstPaymentDateTime.GetHashCode();
                if (this.FinalPaymentDateTime != null)
                    hashCode = hashCode * 59 + this.FinalPaymentDateTime.GetHashCode();
                if (this.Purpose != null)
                    hashCode = hashCode * 59 + this.Purpose.GetHashCode();
                if (this.ExtendedPurpose != null)
                    hashCode = hashCode * 59 + this.ExtendedPurpose.GetHashCode();
                hashCode = hashCode * 59 + this.ChargeBearer.GetHashCode();
                if (this.CurrencyOfTransfer != null)
                    hashCode = hashCode * 59 + this.CurrencyOfTransfer.GetHashCode();
                if (this.DestinationCountryCode != null)
                    hashCode = hashCode * 59 + this.DestinationCountryCode.GetHashCode();
                if (this.InstructedAmount != null)
                    hashCode = hashCode * 59 + this.InstructedAmount.GetHashCode();
                if (this.DebtorAccount != null)
                    hashCode = hashCode * 59 + this.DebtorAccount.GetHashCode();
                if (this.Creditor != null)
                    hashCode = hashCode * 59 + this.Creditor.GetHashCode();
                if (this.CreditorAgent != null)
                    hashCode = hashCode * 59 + this.CreditorAgent.GetHashCode();
                if (this.CreditorAccount != null)
                    hashCode = hashCode * 59 + this.CreditorAccount.GetHashCode();
                if (this.SupplementaryData != null)
                    hashCode = hashCode * 59 + this.SupplementaryData.GetHashCode();
                return hashCode;
            }
        }

        /// <summary>
        /// To validate all properties of the instance
        /// </summary>
        /// <param name="validationContext">Validation context</param>
        /// <returns>Validation Result</returns>
        IEnumerable<System.ComponentModel.DataAnnotations.ValidationResult> IValidatableObject.Validate(ValidationContext validationContext)
        {
            // Frequency (string) pattern
            Regex regexFrequency = new Regex(@"^(EvryDay)$|^(EvryWorkgDay)$|^(IntrvlDay:((0[2-9])|([1-2][0-9])|3[0-1]))$|^(IntrvlWkDay:0[1-9]:0[1-7])$|^(WkInMnthDay:0[1-5]:0[1-7])$|^(IntrvlMnthDay:(0[1-6]|12|24):(-0[1-5]|0[1-9]|[12][0-9]|3[01]))$|^(QtrDay:(ENGLISH|SCOTTISH|RECEIVED))$", RegexOptions.CultureInvariant);
            if (false == regexFrequency.Match(this.Frequency).Success)
            {
                yield return new System.ComponentModel.DataAnnotations.ValidationResult("Invalid value for Frequency, must match a pattern of " + regexFrequency, new [] { "Frequency" });
            }

            // Reference (string) maxLength
            if(this.Reference != null && this.Reference.Length > 35)
            {
                yield return new System.ComponentModel.DataAnnotations.ValidationResult("Invalid value for Reference, length must be less than 35.", new [] { "Reference" });
            }

            // Reference (string) minLength
            if(this.Reference != null && this.Reference.Length < 1)
            {
                yield return new System.ComponentModel.DataAnnotations.ValidationResult("Invalid value for Reference, length must be greater than 1.", new [] { "Reference" });
            }

            // NumberOfPayments (string) maxLength
            if(this.NumberOfPayments != null && this.NumberOfPayments.Length > 35)
            {
                yield return new System.ComponentModel.DataAnnotations.ValidationResult("Invalid value for NumberOfPayments, length must be less than 35.", new [] { "NumberOfPayments" });
            }

            // NumberOfPayments (string) minLength
            if(this.NumberOfPayments != null && this.NumberOfPayments.Length < 1)
            {
                yield return new System.ComponentModel.DataAnnotations.ValidationResult("Invalid value for NumberOfPayments, length must be greater than 1.", new [] { "NumberOfPayments" });
            }

            // Purpose (string) maxLength
            if(this.Purpose != null && this.Purpose.Length > 4)
            {
                yield return new System.ComponentModel.DataAnnotations.ValidationResult("Invalid value for Purpose, length must be less than 4.", new [] { "Purpose" });
            }

            // Purpose (string) minLength
            if(this.Purpose != null && this.Purpose.Length < 1)
            {
                yield return new System.ComponentModel.DataAnnotations.ValidationResult("Invalid value for Purpose, length must be greater than 1.", new [] { "Purpose" });
            }

            // ExtendedPurpose (string) maxLength
            if(this.ExtendedPurpose != null && this.ExtendedPurpose.Length > 140)
            {
                yield return new System.ComponentModel.DataAnnotations.ValidationResult("Invalid value for ExtendedPurpose, length must be less than 140.", new [] { "ExtendedPurpose" });
            }

            // ExtendedPurpose (string) minLength
            if(this.ExtendedPurpose != null && this.ExtendedPurpose.Length < 1)
            {
                yield return new System.ComponentModel.DataAnnotations.ValidationResult("Invalid value for ExtendedPurpose, length must be greater than 1.", new [] { "ExtendedPurpose" });
            }

            // CurrencyOfTransfer (string) pattern
            Regex regexCurrencyOfTransfer = new Regex(@"^[A-Z]{3,3}$", RegexOptions.CultureInvariant);
            if (false == regexCurrencyOfTransfer.Match(this.CurrencyOfTransfer).Success)
            {
                yield return new System.ComponentModel.DataAnnotations.ValidationResult("Invalid value for CurrencyOfTransfer, must match a pattern of " + regexCurrencyOfTransfer, new [] { "CurrencyOfTransfer" });
            }

            // DestinationCountryCode (string) pattern
            Regex regexDestinationCountryCode = new Regex(@"[A-Z]{2,2}", RegexOptions.CultureInvariant);
            if (false == regexDestinationCountryCode.Match(this.DestinationCountryCode).Success)
            {
                yield return new System.ComponentModel.DataAnnotations.ValidationResult("Invalid value for DestinationCountryCode, must match a pattern of " + regexDestinationCountryCode, new [] { "DestinationCountryCode" });
            }

            yield break;
        }
    }

}
