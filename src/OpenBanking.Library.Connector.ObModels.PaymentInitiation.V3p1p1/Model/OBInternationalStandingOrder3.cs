/* 
 * Payment Initiation API
 *
 * OpenAPI for Payment Initiation API Specification
 *
 * The version of the OpenAPI document: v3.1.1
 * Contact: ServiceDesk@openbanking.org.uk
 * Generated by: https://github.com/openapitools/openapi-generator.git
 */


using System;
using System.Collections.Generic;
using System.ComponentModel.DataAnnotations;
using System.Runtime.Serialization;
using System.Text;
using System.Text.RegularExpressions;
using Newtonsoft.Json;

namespace FinnovationLabs.OpenBanking.Library.Connector.ObModels.PaymentInitiation.V3p1p1.Model
{
    /// <summary>
    /// The Initiation payload is sent by the initiating party to the ASPSP. It is used to request movement of funds from the debtor account to a creditor for an international standing order.
    /// </summary>
    [DataContract]
    public partial class OBInternationalStandingOrder3 :  IEquatable<OBInternationalStandingOrder3>, IValidatableObject
    {
        /// <summary>
        /// Gets or Sets ChargeBearer
        /// </summary>
        [DataMember(Name="ChargeBearer", EmitDefaultValue=false)]
        public OBChargeBearerType1Code? ChargeBearer { get; set; }
        /// <summary>
        /// Initializes a new instance of the <see cref="OBInternationalStandingOrder3" /> class.
        /// </summary>
        [JsonConstructor]
        protected OBInternationalStandingOrder3() { }
        /// <summary>
        /// Initializes a new instance of the <see cref="OBInternationalStandingOrder3" /> class.
        /// </summary>
        /// <param name="frequency">Individual Definitions: EvryDay - Every day EvryWorkgDay - Every working day IntrvlDay - An interval specified in number of calendar days (02 to 31) IntrvlWkDay - An interval specified in weeks (01 to 09), and the day within the week (01 to 07) WkInMnthDay - A monthly interval, specifying the week of the month (01 to 05) and day within the week (01 to 07) IntrvlMnthDay - An interval specified in months (between 01 to 06, 12, 24), specifying the day within the month (-5 to -1, 1 to 31) QtrDay - Quarterly (either ENGLISH, SCOTTISH, or RECEIVED). ENGLISH &#x3D; Paid on the 25th March, 24th June, 29th September and 25th December. SCOTTISH &#x3D; Paid on the 2nd February, 15th May, 1st August and 11th November. RECEIVED &#x3D; Paid on the 20th March, 19th June, 24th September and 20th December. Individual Patterns: EvryDay (ScheduleCode) EvryWorkgDay (ScheduleCode) IntrvlDay:NoOfDay (ScheduleCode + NoOfDay) IntrvlWkDay:IntervalInWeeks:DayInWeek (ScheduleCode + IntervalInWeeks + DayInWeek) WkInMnthDay:WeekInMonth:DayInWeek (ScheduleCode + WeekInMonth + DayInWeek) IntrvlMnthDay:IntervalInMonths:DayInMonth (ScheduleCode + IntervalInMonths + DayInMonth) QtrDay: + either (ENGLISH, SCOTTISH or RECEIVED) ScheduleCode + QuarterDay The regular expression for this element combines five smaller versions for each permitted pattern. To aid legibility - the components are presented individually here: EvryDay EvryWorkgDay IntrvlDay:((0[2-9])|([1-2][0-9])|3[0-1]) IntrvlWkDay:0[1-9]:0[1-7] WkInMnthDay:0[1-5]:0[1-7] IntrvlMnthDay:(0[1-6]|12|24):(-0[1-5]|0[1-9]|[12][0-9]|3[01]) QtrDay:(ENGLISH|SCOTTISH|RECEIVED) Full Regular Expression: ^(EvryDay)$|^(EvryWorkgDay)$|^(IntrvlDay:((0[2-9])|([1-2][0-9])|3[0-1]))$|^(IntrvlWkDay:0[1-9]:0[1-7])$|^(WkInMnthDay:0[1-5]:0[1-7])$|^(IntrvlMnthDay:(0[1-6]|12|24):(-0[1-5]|0[1-9]|[12][0-9]|3[01]))$|^(QtrDay:(ENGLISH|SCOTTISH|RECEIVED))$ (required).</param>
        /// <param name="reference">Unique reference, as assigned by the creditor, to unambiguously refer to the payment transaction. Usage: If available, the initiating party should provide this reference in the structured remittance information, to enable reconciliation by the creditor upon receipt of the amount of money. If the business context requires the use of a creditor reference or a payment remit identification, and only one identifier can be passed through the end-to-end chain, the creditor&#39;s reference or payment remittance identification should be quoted in the end-to-end transaction identification..</param>
        /// <param name="numberOfPayments">Number of the payments that will be made in completing this frequency sequence including any executed since the sequence start date..</param>
        /// <param name="firstPaymentDateTime">The date on which the first payment for a Standing Order schedule will be made. All dates in the JSON payloads are represented in ISO 8601 date-time format.  All date-time fields in responses must include the timezone. An example is below: 2017-04-05T10:43:07+00:00 (required).</param>
        /// <param name="finalPaymentDateTime">The date on which the final payment for a Standing Order schedule will be made. All dates in the JSON payloads are represented in ISO 8601 date-time format.  All date-time fields in responses must include the timezone. An example is below: 2017-04-05T10:43:07+00:00.</param>
        /// <param name="purpose">Specifies the external purpose code in the format of character string with a maximum length of 4 characters. The list of valid codes is an external code list published separately. External code sets can be downloaded from www.iso20022.org..</param>
        /// <param name="chargeBearer">chargeBearer.</param>
        /// <param name="currencyOfTransfer">Specifies the currency of the to be transferred amount, which is different from the currency of the debtor&#39;s account. (required).</param>
        /// <param name="instructedAmount">instructedAmount (required).</param>
        /// <param name="debtorAccount">debtorAccount.</param>
        /// <param name="creditor">creditor.</param>
        /// <param name="creditorAgent">creditorAgent.</param>
        /// <param name="creditorAccount">creditorAccount (required).</param>
        /// <param name="supplementaryData">Additional information that can not be captured in the structured fields and/or any other specific block..</param>
        public OBInternationalStandingOrder3(string frequency = default(string), string reference = default(string), string numberOfPayments = default(string), DateTimeOffset firstPaymentDateTime = default(DateTimeOffset), DateTimeOffset finalPaymentDateTime = default(DateTimeOffset), string purpose = default(string), OBChargeBearerType1Code? chargeBearer = default(OBChargeBearerType1Code?), string currencyOfTransfer = default(string), OBDomestic2InstructedAmount instructedAmount = default(OBDomestic2InstructedAmount), OBCashAccountDebtor4 debtorAccount = default(OBCashAccountDebtor4), OBPartyIdentification43 creditor = default(OBPartyIdentification43), OBBranchAndFinancialInstitutionIdentification6 creditorAgent = default(OBBranchAndFinancialInstitutionIdentification6), OBCashAccountCreditor3 creditorAccount = default(OBCashAccountCreditor3), Object supplementaryData = default(Object))
        {
            // to ensure "frequency" is required (not null)
            this.Frequency = frequency ?? throw new ArgumentNullException("frequency is a required property for OBInternationalStandingOrder3 and cannot be null");
            this.FirstPaymentDateTime = firstPaymentDateTime;
            // to ensure "currencyOfTransfer" is required (not null)
            this.CurrencyOfTransfer = currencyOfTransfer ?? throw new ArgumentNullException("currencyOfTransfer is a required property for OBInternationalStandingOrder3 and cannot be null");
            // to ensure "instructedAmount" is required (not null)
            this.InstructedAmount = instructedAmount ?? throw new ArgumentNullException("instructedAmount is a required property for OBInternationalStandingOrder3 and cannot be null");
            // to ensure "creditorAccount" is required (not null)
            this.CreditorAccount = creditorAccount ?? throw new ArgumentNullException("creditorAccount is a required property for OBInternationalStandingOrder3 and cannot be null");
            this.Reference = reference;
            this.NumberOfPayments = numberOfPayments;
            this.FinalPaymentDateTime = finalPaymentDateTime;
            this.Purpose = purpose;
            this.ChargeBearer = chargeBearer;
            this.DebtorAccount = debtorAccount;
            this.Creditor = creditor;
            this.CreditorAgent = creditorAgent;
            this.SupplementaryData = supplementaryData;
        }
        
        /// <summary>
        /// Individual Definitions: EvryDay - Every day EvryWorkgDay - Every working day IntrvlDay - An interval specified in number of calendar days (02 to 31) IntrvlWkDay - An interval specified in weeks (01 to 09), and the day within the week (01 to 07) WkInMnthDay - A monthly interval, specifying the week of the month (01 to 05) and day within the week (01 to 07) IntrvlMnthDay - An interval specified in months (between 01 to 06, 12, 24), specifying the day within the month (-5 to -1, 1 to 31) QtrDay - Quarterly (either ENGLISH, SCOTTISH, or RECEIVED). ENGLISH &#x3D; Paid on the 25th March, 24th June, 29th September and 25th December. SCOTTISH &#x3D; Paid on the 2nd February, 15th May, 1st August and 11th November. RECEIVED &#x3D; Paid on the 20th March, 19th June, 24th September and 20th December. Individual Patterns: EvryDay (ScheduleCode) EvryWorkgDay (ScheduleCode) IntrvlDay:NoOfDay (ScheduleCode + NoOfDay) IntrvlWkDay:IntervalInWeeks:DayInWeek (ScheduleCode + IntervalInWeeks + DayInWeek) WkInMnthDay:WeekInMonth:DayInWeek (ScheduleCode + WeekInMonth + DayInWeek) IntrvlMnthDay:IntervalInMonths:DayInMonth (ScheduleCode + IntervalInMonths + DayInMonth) QtrDay: + either (ENGLISH, SCOTTISH or RECEIVED) ScheduleCode + QuarterDay The regular expression for this element combines five smaller versions for each permitted pattern. To aid legibility - the components are presented individually here: EvryDay EvryWorkgDay IntrvlDay:((0[2-9])|([1-2][0-9])|3[0-1]) IntrvlWkDay:0[1-9]:0[1-7] WkInMnthDay:0[1-5]:0[1-7] IntrvlMnthDay:(0[1-6]|12|24):(-0[1-5]|0[1-9]|[12][0-9]|3[01]) QtrDay:(ENGLISH|SCOTTISH|RECEIVED) Full Regular Expression: ^(EvryDay)$|^(EvryWorkgDay)$|^(IntrvlDay:((0[2-9])|([1-2][0-9])|3[0-1]))$|^(IntrvlWkDay:0[1-9]:0[1-7])$|^(WkInMnthDay:0[1-5]:0[1-7])$|^(IntrvlMnthDay:(0[1-6]|12|24):(-0[1-5]|0[1-9]|[12][0-9]|3[01]))$|^(QtrDay:(ENGLISH|SCOTTISH|RECEIVED))$
        /// </summary>
        /// <value>Individual Definitions: EvryDay - Every day EvryWorkgDay - Every working day IntrvlDay - An interval specified in number of calendar days (02 to 31) IntrvlWkDay - An interval specified in weeks (01 to 09), and the day within the week (01 to 07) WkInMnthDay - A monthly interval, specifying the week of the month (01 to 05) and day within the week (01 to 07) IntrvlMnthDay - An interval specified in months (between 01 to 06, 12, 24), specifying the day within the month (-5 to -1, 1 to 31) QtrDay - Quarterly (either ENGLISH, SCOTTISH, or RECEIVED). ENGLISH &#x3D; Paid on the 25th March, 24th June, 29th September and 25th December. SCOTTISH &#x3D; Paid on the 2nd February, 15th May, 1st August and 11th November. RECEIVED &#x3D; Paid on the 20th March, 19th June, 24th September and 20th December. Individual Patterns: EvryDay (ScheduleCode) EvryWorkgDay (ScheduleCode) IntrvlDay:NoOfDay (ScheduleCode + NoOfDay) IntrvlWkDay:IntervalInWeeks:DayInWeek (ScheduleCode + IntervalInWeeks + DayInWeek) WkInMnthDay:WeekInMonth:DayInWeek (ScheduleCode + WeekInMonth + DayInWeek) IntrvlMnthDay:IntervalInMonths:DayInMonth (ScheduleCode + IntervalInMonths + DayInMonth) QtrDay: + either (ENGLISH, SCOTTISH or RECEIVED) ScheduleCode + QuarterDay The regular expression for this element combines five smaller versions for each permitted pattern. To aid legibility - the components are presented individually here: EvryDay EvryWorkgDay IntrvlDay:((0[2-9])|([1-2][0-9])|3[0-1]) IntrvlWkDay:0[1-9]:0[1-7] WkInMnthDay:0[1-5]:0[1-7] IntrvlMnthDay:(0[1-6]|12|24):(-0[1-5]|0[1-9]|[12][0-9]|3[01]) QtrDay:(ENGLISH|SCOTTISH|RECEIVED) Full Regular Expression: ^(EvryDay)$|^(EvryWorkgDay)$|^(IntrvlDay:((0[2-9])|([1-2][0-9])|3[0-1]))$|^(IntrvlWkDay:0[1-9]:0[1-7])$|^(WkInMnthDay:0[1-5]:0[1-7])$|^(IntrvlMnthDay:(0[1-6]|12|24):(-0[1-5]|0[1-9]|[12][0-9]|3[01]))$|^(QtrDay:(ENGLISH|SCOTTISH|RECEIVED))$</value>
        [DataMember(Name="Frequency", EmitDefaultValue=false)]
        public string Frequency { get; set; }

        /// <summary>
        /// Unique reference, as assigned by the creditor, to unambiguously refer to the payment transaction. Usage: If available, the initiating party should provide this reference in the structured remittance information, to enable reconciliation by the creditor upon receipt of the amount of money. If the business context requires the use of a creditor reference or a payment remit identification, and only one identifier can be passed through the end-to-end chain, the creditor&#39;s reference or payment remittance identification should be quoted in the end-to-end transaction identification.
        /// </summary>
        /// <value>Unique reference, as assigned by the creditor, to unambiguously refer to the payment transaction. Usage: If available, the initiating party should provide this reference in the structured remittance information, to enable reconciliation by the creditor upon receipt of the amount of money. If the business context requires the use of a creditor reference or a payment remit identification, and only one identifier can be passed through the end-to-end chain, the creditor&#39;s reference or payment remittance identification should be quoted in the end-to-end transaction identification.</value>
        [DataMember(Name="Reference", EmitDefaultValue=false)]
        public string Reference { get; set; }

        /// <summary>
        /// Number of the payments that will be made in completing this frequency sequence including any executed since the sequence start date.
        /// </summary>
        /// <value>Number of the payments that will be made in completing this frequency sequence including any executed since the sequence start date.</value>
        [DataMember(Name="NumberOfPayments", EmitDefaultValue=false)]
        public string NumberOfPayments { get; set; }

        /// <summary>
        /// The date on which the first payment for a Standing Order schedule will be made. All dates in the JSON payloads are represented in ISO 8601 date-time format.  All date-time fields in responses must include the timezone. An example is below: 2017-04-05T10:43:07+00:00
        /// </summary>
        /// <value>The date on which the first payment for a Standing Order schedule will be made. All dates in the JSON payloads are represented in ISO 8601 date-time format.  All date-time fields in responses must include the timezone. An example is below: 2017-04-05T10:43:07+00:00</value>
        [DataMember(Name="FirstPaymentDateTime", EmitDefaultValue=false)]
        public DateTimeOffset FirstPaymentDateTime { get; set; }

        /// <summary>
        /// The date on which the final payment for a Standing Order schedule will be made. All dates in the JSON payloads are represented in ISO 8601 date-time format.  All date-time fields in responses must include the timezone. An example is below: 2017-04-05T10:43:07+00:00
        /// </summary>
        /// <value>The date on which the final payment for a Standing Order schedule will be made. All dates in the JSON payloads are represented in ISO 8601 date-time format.  All date-time fields in responses must include the timezone. An example is below: 2017-04-05T10:43:07+00:00</value>
        [DataMember(Name="FinalPaymentDateTime", EmitDefaultValue=false)]
        public DateTimeOffset FinalPaymentDateTime { get; set; }

        /// <summary>
        /// Specifies the external purpose code in the format of character string with a maximum length of 4 characters. The list of valid codes is an external code list published separately. External code sets can be downloaded from www.iso20022.org.
        /// </summary>
        /// <value>Specifies the external purpose code in the format of character string with a maximum length of 4 characters. The list of valid codes is an external code list published separately. External code sets can be downloaded from www.iso20022.org.</value>
        [DataMember(Name="Purpose", EmitDefaultValue=false)]
        public string Purpose { get; set; }

        /// <summary>
        /// Specifies the currency of the to be transferred amount, which is different from the currency of the debtor&#39;s account.
        /// </summary>
        /// <value>Specifies the currency of the to be transferred amount, which is different from the currency of the debtor&#39;s account.</value>
        [DataMember(Name="CurrencyOfTransfer", EmitDefaultValue=false)]
        public string CurrencyOfTransfer { get; set; }

        /// <summary>
        /// Gets or Sets InstructedAmount
        /// </summary>
        [DataMember(Name="InstructedAmount", EmitDefaultValue=false)]
        public OBDomestic2InstructedAmount InstructedAmount { get; set; }

        /// <summary>
        /// Gets or Sets DebtorAccount
        /// </summary>
        [DataMember(Name="DebtorAccount", EmitDefaultValue=false)]
        public OBCashAccountDebtor4 DebtorAccount { get; set; }

        /// <summary>
        /// Gets or Sets Creditor
        /// </summary>
        [DataMember(Name="Creditor", EmitDefaultValue=false)]
        public OBPartyIdentification43 Creditor { get; set; }

        /// <summary>
        /// Gets or Sets CreditorAgent
        /// </summary>
        [DataMember(Name="CreditorAgent", EmitDefaultValue=false)]
        public OBBranchAndFinancialInstitutionIdentification6 CreditorAgent { get; set; }

        /// <summary>
        /// Gets or Sets CreditorAccount
        /// </summary>
        [DataMember(Name="CreditorAccount", EmitDefaultValue=false)]
        public OBCashAccountCreditor3 CreditorAccount { get; set; }

        /// <summary>
        /// Additional information that can not be captured in the structured fields and/or any other specific block.
        /// </summary>
        /// <value>Additional information that can not be captured in the structured fields and/or any other specific block.</value>
        [DataMember(Name="SupplementaryData", EmitDefaultValue=false)]
        public Object SupplementaryData { get; set; }

        /// <summary>
        /// Returns the string presentation of the object
        /// </summary>
        /// <returns>String presentation of the object</returns>
        public override string ToString()
        {
            var sb = new StringBuilder();
            sb.Append("class OBInternationalStandingOrder3 {\n");
            sb.Append("  Frequency: ").Append(Frequency).Append("\n");
            sb.Append("  Reference: ").Append(Reference).Append("\n");
            sb.Append("  NumberOfPayments: ").Append(NumberOfPayments).Append("\n");
            sb.Append("  FirstPaymentDateTime: ").Append(FirstPaymentDateTime).Append("\n");
            sb.Append("  FinalPaymentDateTime: ").Append(FinalPaymentDateTime).Append("\n");
            sb.Append("  Purpose: ").Append(Purpose).Append("\n");
            sb.Append("  ChargeBearer: ").Append(ChargeBearer).Append("\n");
            sb.Append("  CurrencyOfTransfer: ").Append(CurrencyOfTransfer).Append("\n");
            sb.Append("  InstructedAmount: ").Append(InstructedAmount).Append("\n");
            sb.Append("  DebtorAccount: ").Append(DebtorAccount).Append("\n");
            sb.Append("  Creditor: ").Append(Creditor).Append("\n");
            sb.Append("  CreditorAgent: ").Append(CreditorAgent).Append("\n");
            sb.Append("  CreditorAccount: ").Append(CreditorAccount).Append("\n");
            sb.Append("  SupplementaryData: ").Append(SupplementaryData).Append("\n");
            sb.Append("}\n");
            return sb.ToString();
        }
  
        /// <summary>
        /// Returns the JSON string presentation of the object
        /// </summary>
        /// <returns>JSON string presentation of the object</returns>
        public virtual string ToJson()
        {
            return JsonConvert.SerializeObject(this, Formatting.Indented);
        }

        /// <summary>
        /// Returns true if objects are equal
        /// </summary>
        /// <param name="input">Object to be compared</param>
        /// <returns>Boolean</returns>
        public override bool Equals(object input)
        {
            return this.Equals(input as OBInternationalStandingOrder3);
        }

        /// <summary>
        /// Returns true if OBInternationalStandingOrder3 instances are equal
        /// </summary>
        /// <param name="input">Instance of OBInternationalStandingOrder3 to be compared</param>
        /// <returns>Boolean</returns>
        public bool Equals(OBInternationalStandingOrder3 input)
        {
            if (input == null)
                return false;

            return 
                (
                    this.Frequency == input.Frequency ||
                    (this.Frequency != null &&
                    this.Frequency.Equals(input.Frequency))
                ) && 
                (
                    this.Reference == input.Reference ||
                    (this.Reference != null &&
                    this.Reference.Equals(input.Reference))
                ) && 
                (
                    this.NumberOfPayments == input.NumberOfPayments ||
                    (this.NumberOfPayments != null &&
                    this.NumberOfPayments.Equals(input.NumberOfPayments))
                ) && 
                (
                    this.FirstPaymentDateTime == input.FirstPaymentDateTime ||
                    (this.FirstPaymentDateTime != null &&
                    this.FirstPaymentDateTime.Equals(input.FirstPaymentDateTime))
                ) && 
                (
                    this.FinalPaymentDateTime == input.FinalPaymentDateTime ||
                    (this.FinalPaymentDateTime != null &&
                    this.FinalPaymentDateTime.Equals(input.FinalPaymentDateTime))
                ) && 
                (
                    this.Purpose == input.Purpose ||
                    (this.Purpose != null &&
                    this.Purpose.Equals(input.Purpose))
                ) && 
                (
                    this.ChargeBearer == input.ChargeBearer ||
                    this.ChargeBearer.Equals(input.ChargeBearer)
                ) && 
                (
                    this.CurrencyOfTransfer == input.CurrencyOfTransfer ||
                    (this.CurrencyOfTransfer != null &&
                    this.CurrencyOfTransfer.Equals(input.CurrencyOfTransfer))
                ) && 
                (
                    this.InstructedAmount == input.InstructedAmount ||
                    (this.InstructedAmount != null &&
                    this.InstructedAmount.Equals(input.InstructedAmount))
                ) && 
                (
                    this.DebtorAccount == input.DebtorAccount ||
                    (this.DebtorAccount != null &&
                    this.DebtorAccount.Equals(input.DebtorAccount))
                ) && 
                (
                    this.Creditor == input.Creditor ||
                    (this.Creditor != null &&
                    this.Creditor.Equals(input.Creditor))
                ) && 
                (
                    this.CreditorAgent == input.CreditorAgent ||
                    (this.CreditorAgent != null &&
                    this.CreditorAgent.Equals(input.CreditorAgent))
                ) && 
                (
                    this.CreditorAccount == input.CreditorAccount ||
                    (this.CreditorAccount != null &&
                    this.CreditorAccount.Equals(input.CreditorAccount))
                ) && 
                (
                    this.SupplementaryData == input.SupplementaryData ||
                    (this.SupplementaryData != null &&
                    this.SupplementaryData.Equals(input.SupplementaryData))
                );
        }

        /// <summary>
        /// Gets the hash code
        /// </summary>
        /// <returns>Hash code</returns>
        public override int GetHashCode()
        {
            unchecked // Overflow is fine, just wrap
            {
                int hashCode = 41;
                if (this.Frequency != null)
                    hashCode = hashCode * 59 + this.Frequency.GetHashCode();
                if (this.Reference != null)
                    hashCode = hashCode * 59 + this.Reference.GetHashCode();
                if (this.NumberOfPayments != null)
                    hashCode = hashCode * 59 + this.NumberOfPayments.GetHashCode();
                if (this.FirstPaymentDateTime != null)
                    hashCode = hashCode * 59 + this.FirstPaymentDateTime.GetHashCode();
                if (this.FinalPaymentDateTime != null)
                    hashCode = hashCode * 59 + this.FinalPaymentDateTime.GetHashCode();
                if (this.Purpose != null)
                    hashCode = hashCode * 59 + this.Purpose.GetHashCode();
                hashCode = hashCode * 59 + this.ChargeBearer.GetHashCode();
                if (this.CurrencyOfTransfer != null)
                    hashCode = hashCode * 59 + this.CurrencyOfTransfer.GetHashCode();
                if (this.InstructedAmount != null)
                    hashCode = hashCode * 59 + this.InstructedAmount.GetHashCode();
                if (this.DebtorAccount != null)
                    hashCode = hashCode * 59 + this.DebtorAccount.GetHashCode();
                if (this.Creditor != null)
                    hashCode = hashCode * 59 + this.Creditor.GetHashCode();
                if (this.CreditorAgent != null)
                    hashCode = hashCode * 59 + this.CreditorAgent.GetHashCode();
                if (this.CreditorAccount != null)
                    hashCode = hashCode * 59 + this.CreditorAccount.GetHashCode();
                if (this.SupplementaryData != null)
                    hashCode = hashCode * 59 + this.SupplementaryData.GetHashCode();
                return hashCode;
            }
        }

        /// <summary>
        /// To validate all properties of the instance
        /// </summary>
        /// <param name="validationContext">Validation context</param>
        /// <returns>Validation Result</returns>
        IEnumerable<System.ComponentModel.DataAnnotations.ValidationResult> IValidatableObject.Validate(ValidationContext validationContext)
        {
            // Frequency (string) maxLength
            if(this.Frequency != null && this.Frequency.Length > 35)
            {
                yield return new System.ComponentModel.DataAnnotations.ValidationResult("Invalid value for Frequency, length must be less than 35.", new [] { "Frequency" });
            }

            // Frequency (string) minLength
            if(this.Frequency != null && this.Frequency.Length < 1)
            {
                yield return new System.ComponentModel.DataAnnotations.ValidationResult("Invalid value for Frequency, length must be greater than 1.", new [] { "Frequency" });
            }

            // Frequency (string) pattern
            Regex regexFrequency = new Regex(@"^(EvryDay)$|^(EvryWorkgDay)$|^(IntrvlDay:((0[2-9])|([1-2][0-9])|3[0-1]))$|^(IntrvlWkDay:0[1-9]:0[1-7])$|^(WkInMnthDay:0[1-5]:0[1-7])$|^(IntrvlMnthDay:(0[1-6]|12|24):(-0[1-5]|0[1-9]|[12][0-9]|3[01]))$|^(QtrDay:(ENGLISH|SCOTTISH|RECEIVED))$", RegexOptions.CultureInvariant);
            if (false == regexFrequency.Match(this.Frequency).Success)
            {
                yield return new System.ComponentModel.DataAnnotations.ValidationResult("Invalid value for Frequency, must match a pattern of " + regexFrequency, new [] { "Frequency" });
            }

            // Reference (string) maxLength
            if(this.Reference != null && this.Reference.Length > 35)
            {
                yield return new System.ComponentModel.DataAnnotations.ValidationResult("Invalid value for Reference, length must be less than 35.", new [] { "Reference" });
            }

            // Reference (string) minLength
            if(this.Reference != null && this.Reference.Length < 1)
            {
                yield return new System.ComponentModel.DataAnnotations.ValidationResult("Invalid value for Reference, length must be greater than 1.", new [] { "Reference" });
            }

            // NumberOfPayments (string) maxLength
            if(this.NumberOfPayments != null && this.NumberOfPayments.Length > 35)
            {
                yield return new System.ComponentModel.DataAnnotations.ValidationResult("Invalid value for NumberOfPayments, length must be less than 35.", new [] { "NumberOfPayments" });
            }

            // NumberOfPayments (string) minLength
            if(this.NumberOfPayments != null && this.NumberOfPayments.Length < 1)
            {
                yield return new System.ComponentModel.DataAnnotations.ValidationResult("Invalid value for NumberOfPayments, length must be greater than 1.", new [] { "NumberOfPayments" });
            }

            // Purpose (string) maxLength
            if(this.Purpose != null && this.Purpose.Length > 4)
            {
                yield return new System.ComponentModel.DataAnnotations.ValidationResult("Invalid value for Purpose, length must be less than 4.", new [] { "Purpose" });
            }

            // Purpose (string) minLength
            if(this.Purpose != null && this.Purpose.Length < 1)
            {
                yield return new System.ComponentModel.DataAnnotations.ValidationResult("Invalid value for Purpose, length must be greater than 1.", new [] { "Purpose" });
            }

            // CurrencyOfTransfer (string) pattern
            Regex regexCurrencyOfTransfer = new Regex(@"^[A-Z]{3,3}$", RegexOptions.CultureInvariant);
            if (false == regexCurrencyOfTransfer.Match(this.CurrencyOfTransfer).Success)
            {
                yield return new System.ComponentModel.DataAnnotations.ValidationResult("Invalid value for CurrencyOfTransfer, must match a pattern of " + regexCurrencyOfTransfer, new [] { "CurrencyOfTransfer" });
            }

            yield break;
        }
    }

}
